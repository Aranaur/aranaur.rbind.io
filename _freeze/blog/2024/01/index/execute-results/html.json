{
  "hash": "7edd265e12d752c9c576c86fdadc0a11",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Землекористування/покрив України у 2022 році\"\ndate: 2024-02-02\ndate-format: iso\ndescription: \"Візуалізація земляного покриву та землекористування в Україні\"\nimage: \"featured.png\"\ntwitter-card:\n  image: \"featured.png\"\nopen-graph:\n  image: \"featured.png\"\ncategories:\n  - R\n  - map\n  - rayshader\n  - visualisation\ncitation:\n  type: post-weblog\n  author: Ihor Miroshnychenko\n  title: \"Ukraine's land use/cover in 2022\"\n  language: uk-UA\n  available-date: 2024-02-02\n\nformat: \n  html: \n    code-fold: false\nexecute: \n  warning: false\n  message: false\n---\n\n\n::: {.callout-tip}\n## Важливо\n\n- Повний код для цієї візуалізації можна знайти на [GitHub](https://github.com/Aranaur/3d-Ukraine-cover-map)\n- Мапу у високій якості можна завантажити [тут](https://drive.google.com/file/d/15hk9adj-h9uAdCPXD368yEeB8NqgftUp/view)\n:::\n\nКарти землекористування та земляного покриву є важливим інструментом для вивчення взаємодії людини та природи. Вони дозволяють візуалізувати, як змінюється ландшафт внаслідок діяльності людини, а також виявляти тенденції у зміні землекористування. У цій статті я покажу, як можна побудувати вражаючі візуалізації земляного покриву та землекористування за допомогою R та пакету `rayshader`.\n\n# Пакети\n\nДля цієї візуалізації я використовував наступні пакети:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\npacman::p_load(\n    terra, # <1>\n    giscoR, # <2>\n    sf, # <3>\n    tidyverse, # <4>\n    ggtern, # <5>\n    elevatr, # <6>\n    png, # <7>\n    rayshader, # <8>\n    magick, # <9>\n    furrr, # <10>\n    here, # <11>\n    future, # <12>\n    rvest, # <13>\n    RSelenium, # <14>\n    netstat, # <15>\n    janitor, # <16>\n    extrafont # <17>\n)\n```\n:::\n\n\n1. `terra` - для роботи з растровим\n2. `giscoR` - для завантаження геоданих Європейського союзу\n3. `sf` - для роботи з векторними геоданими\n4. `tidyverse` - для роботи з даними\n5. `ggtern` - для побудови тернарних графіків\n6. `elevatr` - для завантаження цифрових моделей рельєфу\n7. `png` - для роботи з зображеннями\n8. `rayshader` - для побудови 3D-візуалізацій\n9. `magick` - для роботи з зображеннями\n10. `furrr` - для паралельних обчислень\n11. `here` - для роботи з шляхами\n12. `future` - для паралельних обчислень\n13. `rvest` - для парсингу веб-сторінок\n14. `RSelenium` - для автоматизації браузера\n15. `netstat` - для роботи з мережевими даними\n16. `janitor` - для роботи з даними\n17. `extrafont` - для роботи з шрифтами\n\n# Завантаження даних\n\nДля візуалізації земляного покриву та землекористування я використовував дані [Sentinel-2 10m land use/land cover time series of the world](https://www.arcgis.com/home/item.html?id=cfcb7609de5f478eb7666240902d4d3d), які підготовлені Impact Observatory, Microsoft та Esri з використанням [моделі глибокого навчання штучного інтелекту Impact Observatory для класифікації земель](https://www.impactobservatory.com/).\n\n## Кордони України\n\nДля початку завантажимо кордони України з [Geoportal of the State Service of Ukraine for Geodesy, Cartography and Cadastre](https://map.land.gov.ua/kadastrova-karta) за допомогою пакету `giscoR`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry_sf <- gisco_get_countries(\n    country = \"UA\", # <1>\n    resolution = \"1\" # <2>\n)\n\nplot(st_geometry(country_sf))\n```\n\n::: {.cell-output-display}\n![Кордони України](index_files/figure-html/fig-ukraine-border-1.png){#fig-ukraine-border width=672}\n:::\n:::\n\n\n1. `country` - код країни згідно з [ISO 3166-1 alpha-2](https://www.iban.com/country-codes)\n2. `resolution` - рівень градації кордонів (1 - країна, 2 - область)\n\nЗбережемо кордони України у файл `ua-borders.png`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npng(\"ua-borders.png\")\n```\n:::\n\n\n## Земляний покрив\n\nЗавантажимо растровий шар земляного покриву для України. Для цього необхідно перейти на сайт <https://livingatlas.arcgis.com/landcoverexplorer> та натиснути кнопку завантаження у лівому нижньому кутку карти.\n\nПісля чого відкриється мапа земляного покриву, на якій можна вибрати область для завантаження. Виберемо всі області, які входять до складу України. Клікаємо на кожну область щоб вибрати плитку та рік:\n\n![](img/esri-1.png)\n\nКопіюємо посилання та зберігаємо їх змінну `urls`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurls <- c(\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/34U_20220101-20230101.tif\",\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/35U_20220101-20230101.tif\",\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/36U_20220101-20230101.tif\",\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/37U_20220101-20230101.tif\",\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/35T_20220101-20230101.tif\",\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/36T_20220101-20230101.tif\",\n    \"https://lulctimeseries.blob.core.windows.net/lulctimeseriesv003/lc2022/37T_20220101-20230101.tif\"\n)\n```\n:::\n\n\nДля завантаження даних використаємо функцію `download.file()`. За замовчування вона завантажує файли впродовж 60 секунд і якщо файл не встиг завантажитись, видасть помилку. Щоб уникнути цього, збільшимо час завантаження до 480 секунд:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(timeout = 480)\n```\n:::\n\n\nСтворимо функцію для завантаження растрових даних якщо вони ще не були завантажені. Це дозволить нам уникнути повторного завантаження файлів, якщо вони вже були завантажені. Імена файлів будуть взяті з посилань за допомогою функції `basename()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_if_not_exists <- function(url) {\n    if (!file.exists(basename(url))) {\n        download.file(url, basename(url), mode = \"wb\")\n    }\n}\n```\n:::\n\n\nЗавантажимо файли за допомогою нашої функції та функції `map()` з пакету `purrr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(urls, download_if_not_exists)\n```\n:::\n\n\n## Об'єднання растрових файлів\n\nЗбережемо перелік всіх завантажених файлів у змінну `raster_files`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_files <- list.files(\n    path = here(), # <1>\n    pattern = \"20230101.tif$\", # <2>\n    full.names = TRUE # <3>\n)\n```\n:::\n\n\n1. `path` - шлях до папки, в якій знаходяться файли. В даному випадку це поточна папка, яку ми отримуємо за допомогою функції `here()`\n2. `pattern` - шаблон імен файлів, які ми шукаємо. В даному випадку це файли, які закінчуються на `20230101.tif`\n3. `full.names` - будемо зберігати повні шляхи до файлів\n\nДля подальшої роботи і об'єднання всіх файлів в один створимо змінну з `crs` в якій буде збережено інформацію про систему координат, в якій знаходяться файли. В даному випадку це [EPSG:32635](https://epsg.io/32635):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs <- \"EPSG:4326\"\n```\n:::\n\n\nОб'єднаємо всі файли в один за допомогою функції `terra::rast()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!file.exists(\"ua_land_cover_vrt.vrt\")){\n    for(raster in raster_files){\n        cat(\"Start with:\", raster, \"\\n\")\n        rasters <- rast(raster) # <1>\n        country <- country_sf %>% # <2>\n            sf::st_transform(\n                crs = crs(\n                    rasters\n                )\n            )\n        land_cover <- crop( # <3>\n            rasters,\n            vect(\n                country\n            ),\n            snap = \"in\",\n            mask = TRUE\n        ) %>% \n        terra::aggregate( # <4>\n            fact = 5,\n            fun = \"modal\"\n        ) %>% \n        terra::project(crs) # <5>\n        # write raster\n        terra::writeRaster( # <6>\n            land_cover,\n            paste0(\n                raster,\n                \"_ua\",\n                \".tif\"\n            ),\n            overwrite=FALSE\n        )\n    }\n  }\n```\n:::\n\n\n1. Завантажуємо растровий файл за допомогою функції `terra::rast()`\n2. Трансформуємо систему координат.\n3. Обрізаємо растровий файл за допомогою векторного файлу кордонів України та зберігаємо його.\n4. Агрегуємо растровий файл для зменшення об'єму даних.\n5. Проектуємо растровий файл в систему координат `EPSG:4326`.\n6. Зберігаємо растровий файл.\n\nНарешті можемо об'єднати всі файли в один за допомогою функції `terra::vrt()`, яка створить віртуальний растровий файл:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_list <- list.files(\n    path = here(),\n    pattern = \"_ua.tif\",\n    full.names = TRUE\n)\n\nland_cover_vrt <- terra::vrt(\n    r_list,\n    \"ua_land_cover_vrt.vrt\",\n    overwrite = TRUE\n)\n```\n:::\n\n\n# Отримання оригінальної палітри кольорів\n\nДля візуалізації земляного покриву нам знадобиться палітра кольорів, яка використовується на оригінальній мапі. Для цього завантажимо один з растрових файлів та витягнемо з нього палітру кольорів:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nras <- rast( # <1>\n    raster_files[[1]]\n)\n\nraster_color_table <- do.call( # <2>\n    data.frame,\n    coltab(ras) # <3>\n)\n```\n:::\n\n\n1. Завантажуємо растровий файл за допомогою функції `terra::rast()`\n2. Створюємо датафрейм з палітрою кольорів\n3. Витягуємо палітру кольорів з растрового файлу\n\nЗверніть увагу на те, що палітра кольорів зберігається у форматі RGB:\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(raster_color_table)\n```\n:::\n\n\nДля подальшої роботи нам знадобиться HEX-код кольорів, тому перетворимо RGB-коди кольорів у HEX-коди за допомогою функції `ggtern::rgb2hex()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_code <- rgb2hex( # <4>\n    r = raster_color_table[,2],\n    g = raster_color_table[,3],\n    b = raster_color_table[,4]\n)\n\nhex_code[1:14]\n```\n:::\n\n\nЯк бачимо, тільки перші 11 спостережень мають HEX-коди. Отже нам потрібні тільки 2-3, 4-5 та 7-11 рядки. Збережемо їх у змінну `cols`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols <- hex_code[c(2:3, 5:6, 8:12)]\n```\n:::\n\n\nТепер ми можемо використати ці кольори для візуалізації земляного покриву:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrom <- c(1:2, 4:5, 7:11) # <1>\nto <- t(col2rgb(cols)) # <2>\n\nland_cover_vrt <- na.omit(land_cover_vrt) # <3>\n\nland_cover_ua <- terra::subst( # <4>\n    land_cover_vrt,\n    from = from,\n    to = to,\n    names = cols\n)\n```\n:::\n\n\n1. Вибираємо рядки з HEX-кодами кольорів\n2. Перетворюємо HEX-коди кольорів у RGB-коди\n3. Видаляємо пропущені значення\n4. Замінюємо кольори у растровому файлі\n\nТепер можемо поглянути на отриманий растровий файл:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::plotRGB(land_cover_ua)\n```\n:::\n\n\n![](img/land_cover_ua_2.png)\n\n# Цифрова модель рельєфу\n\nДля побудови 3D-візуалізації нам знадобиться цифрова модель рельєфу. Завантажимо її за допомогою функції `elevatr::get_elev_raster()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev <- elevatr::get_elev_raster(\n    locations = country_sf, # <1>\n    z = 8, # <2>\n    clip = \"locations\" # <3>\n)\n```\n:::\n\n\n1. `locations` - векторний файл з кордонами України\n2. `z` - масштаб цифрової моделі рельєфу. Для великих територій [рекомендується](https://github.com/tilezen/joerd/blob/master/docs/data-sources.md#what-is-the-ground-resolution) зменшувати масштаб.\n3. `clip` - обрізка за кордонами України\n\nДля об'єднання растрових файлів земляного покриву та цифрової моделі рельєфу нам необхідно перетворити у відповідності один до одного. Для цього ми використаємо проекцію, яку можна знайти за посиланням <https://epsg.io/> для своєї країни:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs_lambert <-\n    \"+proj=tmerc +lat_0=0 +lon_0=21 +k=1 +x_0=300000 +y_0=0 +ellps=krass +towgs84=24,-121,-76,0,0,0,0 +units=m +no_defs +type=crs\"\n```\n:::\n\n\nТепер ми можемо перетворити цифрову модель рельєфу у відповідність до растрового файлу земляного покриву:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nland_cover_ua_resampled <- terra::resample(\n    x = land_cover_ua, # <1>\n    y = terra::rast(elev), # <2>\n    method = \"near\" # <3>\n) %>% \n    terra::project(crs_lambert) # <4>\n```\n:::\n\n\n1. Растровий файл земляного покриву\n2. Цифрова модель рельєфу\n3. Метод перетворення\n4. Проекція\n\nПодивимось на результат:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::plotRGB(land_cover_ua_resampled)\n```\n:::\n\n\n![](img/land_cover_ua_resampled.png)\n\nЗбережемо рисунок у файл `land_cover_ua.png` і зчитаємо його за допомогою пакету `png`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg_file <- \"land_cover_ua.png\"\n\nterra::writeRaster(\n    land_cover_ua_resampled,\n    img_file,\n    overwrite = TRUE,\n    NAflag = 255\n)\n\nimg <- png::readPNG(img_file)\n```\n:::\n\n\n# Створення 3D-візуалізації\n\nПерш ніж створити 3D-візуалізацію, нам необхідно переконатися, що наша растрова модель має однакову проекцію з цифровою моделлю рельєфу. Також нам потрібно перетворити растрову модель у матрицю, щоб пакет `rayshader` міг працювати з нею:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev_lambert <- elev %>%\n   terra::rast() %>%\n   terra::project(crs_lambert)\n\nelmat <- rayshader::raster_to_matrix(\n   elev_lambert \n)\n```\n:::\n\n\nВизначимо висоту та ширину растрової моделі:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- nrow(elev_lambert)\nw <- ncol(elev_lambert)\n```\n:::\n\n\nТепер ми можемо створити 3D-візуалізацію за допомогою пакету `rayshader`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelmat %>% \n    rayshader::height_shade(\n        texture = colorRampPalette(\n            cols[9]\n        )(256)\n    ) %>% \n    rayshader::add_overlay(\n        img,\n        alphalayer = 1\n    ) %>% \n    rayshader::plot_3d(\n        elmat,\n        zscale = 12,\n        solid = FALSE,\n        shadow = TRUE,\n        shadow_darkness = 1,\n        background = \"white\",\n        windowsize = c(\n            w / 10, h / 10\n        ),\n        zoom = .5,\n        phi = 85,\n        theta = 0\n    )\n\nrayshader::render_camera(\n    zoom = .58\n)\n```\n:::\n\n\nВ результаті ми отримаємо 3D-візуалізацію земляного покриву та цифрової моделі рельєфу.\n\n# Рендер рисунку\n\nТепер ми готові зберегти все у високоякісний рисунок. Збережемо його у файл `3d_land_cover_ua-dark.png` за допомогою функції `rayshader::render_highquality()` і використаємо для цього високоякісну текстуру освітлення, яка збережена у файлі `air_museum_playground_4k.hdr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilename <- \"3d_land_cover_ua-dark.png\"\n\nrayshader::render_highquality(\n    filename = filename,\n    preview = TRUE,\n    light = FALSE,\n    environment_light = here('air_museum_playground_4k.hdr'),\n    intensity_env = 1,\n    rotate_env = 90,\n    interactive = FALSE,\n    parallel = TRUE,\n    width = w * 1.5,\n    height = h * 1.5\n)\n```\n:::\n\n\n# Збір статистичної інформації\n\n## Парсинг\n\nТакож хотілося б зібрати статистичну інформацію про земляний покрив України щоб у подальшому додати її у легенду.\n\nДля цього зберемо інформацію зі сторінки опису даних на сайті [Sentinel-2 10m Land Use/Land Cover Time Series](https://www.arcgis.com/home/item.html?id=cfcb7609de5f478eb7666240902d4d3d). \n\nСайт динамічно підтягує контент, тому нам знадобиться пакет `RSelenium` для парсингу даних. Відкриємо вікно браузера та перейдемо на сайт:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndriver <- rsDriver(browser = \"firefox\",\n                   chromever = \"114.0.5735.90\",\n                   verbose = FALSE,\n                   port = free_port())\n\nremDr <- driver$client\n\nremDr$navigate(\"https://www.arcgis.com/home/item.html?id=cfcb7609de5f478eb7666240902d4d3d\")\n```\n:::\n\n\nТепер можемо знайти елементи сторінки за допомогою CSS-селекторів та зібрати інформацію з таблиці:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_table <- remDr$findElement(using = \"xpath\", '/html/body/div[3]/div/div[2]/div/div[2]/div/main/div[2]/div[2]/div[1]/div/div/div/div[8]/table/tbody')\n```\n:::\n\n\nТепер можемо зібрати інформацію з таблиці:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_tbl <- data_table$getPageSource() %>% \n  unlist() %>%\n  read_html() %>% \n  html_table() %>% \n  .[[1]] %>%\n  row_to_names(row_number = 1) %>% \n  mutate(Value = as.factor(Value))\n\nclass_tbl\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 3\n  Value Name               Description                                          \n  <dbl> <chr>              <chr>                                                \n1     1 Water              Areas where water was predominantly present througho…\n2     2 Trees              Any significant clustering of tall (~15 feet or high…\n3     4 Flooded vegetation Areas of any type of vegetation with obvious intermi…\n4     5 Crops              Human planted/plotted cereals, grasses, and crops no…\n5     7 Built Area         Human made structures; major road and rail networks;…\n6     8 Bare ground        Areas of rock or soil with very sparse to no vegetat…\n7     9 Snow/Ice           Large homogenous areas of permanent snow or ice, typ…\n8    10 Clouds             No land cover information due to persistent cloud co…\n9    11 Rangeland          Open areas covered in homogenous grasses with little…\n```\n\n\n:::\n:::\n\n\nЗверніть увагу, що змінна `Value` не містить записів `3` та `6`.\n\n## Підрахунок площі\n\nТепер можемо підрахувати площу кожного класу земляного покриву. На випадок, якщо ми захочемо порахувати площі окремо для кожної області, додамо `id` до змінної `country_sf`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry_sf$id <- 1:nrow(country_sf)\n```\n:::\n\n\nЗберемо всі класи земляного покриву у змінну `classes`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclasses <- class_tbl$Value\n```\n:::\n\n\nПроведемо підрахунок статистики для кожного класу земляного покриву за допомогою функції `exactextractr::exact_extract()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzonal_stats_ukr <- exact_extract(\n  land_cover_vrt,\n  country_sf\n)\n```\n:::\n\n\nТепер можемо підрахувати пропорції площі кожного класу земляного покриву. Для цього використаємо паралельні обчислення за допомогою пакету `future`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession)\n\nukraine_multiclass <- future_map_dfr(zonal_stats_ukr, function(x) {\n  as.data.frame(\n    prop.table(\n      table(factor(x[, 1], levels = classes))\n    )\n  )\n})\n```\n:::\n\n\nОб'єднаємо результати з попередньою таблицею, додамо змінну `colors`, яка буде містити палітру кольорів для кожного класу земляного покриву, а також змінну `perc`, яка буде містити відсотове співвідношення площі кожного класу земляного покриву. Відсортуємо результати за спаданням площі та видалимо класи, які не мають значення:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nukraine_multiclass_sf <- ukraine_multiclass %>% \n  as_tibble() %>%\n  left_join(\n    class_tbl,\n    by = c(\"Var1\" = \"Value\")\n  ) %>% \n  mutate(colors = c(\n    \"#419bdf\", \"#397d49\", \"#7a87c6\", \n    \"#e49635\", \"#c4281b\", \"#a59b8f\", \n    \"#a8ebff\", \"#616161\", \"#e3e2c3\"\n  ), .after = Name,\n  perc = scales::percent(Freq / sum(Freq), accuracy = .01, trim = FALSE)) %>% \n  arrange(desc(Freq)) %>% \n  filter(!(Name %in% c(\"Bare ground\", 'Snow/Ice', 'Clouds')))\n```\n:::\n\n\n# Збираємо фінальну візуалізацію\n\n## Легенда\n\nТепер можемо побудувати легенду для нашої візуалізації. Для цього використаємо пакет `ggplot2`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot <- ukraine_multiclass_sf %>% \n  ggplot(aes(x = Freq, y = fct_reorder(Name, Freq))) +\n  geom_col(aes(fill = fct_reorder(Name, Freq))) +\n  geom_text(\n    aes(label = perc), size = 8, hjust = -0.1, vjust = 0.5, family = \"Fira Sans\", fontface = \"bold\") +\n  scale_fill_manual(values = rev(ukraine_multiclass_sf$colors)) +\n  theme_void() +\n  coord_cartesian(clip = \"off\") +\n  scale_x_continuous(expand = c(.01, .01)) +\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_text(size = 28, hjust = 1, family = \"Georgia\"),\n    plot.margin = margin(15, 85, 15, 15))\n\nplot\n```\n:::\n\n\n![](img/land_cover_legend.png)\n\nЗбережемо легенду у файл `land_cover_legend.png`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlegend_name <- \"land_cover_legend.png\"\nggsave(legend_name, plot, width = 10, height = 6)\n```\n:::\n\n\n## Збірка фінальної візуалізації\n\nЗа допомогою пакету `magick` можемо зберегти всі елементи візуалізації у один файл:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlc_img <- magick::image_read(\n  filename\n)\n\nmy_legend <- magick::image_read(\n  legend_name\n)\n\nmy_legend_scaled <- magick::image_scale(\n  magick::image_background(\n    my_legend, \"none\"\n  ), 2500\n)\n\np <- magick::image_composite(\n    magick::image_scale(\n        lc_img, \"x7000\" \n    ),\n    my_legend_scaled,\n    gravity = \"southwest\",\n    offset = \"+1000+1000\"\n    ) %>% \n    image_annotate(\n    \"Land cover in 2022\",\n    size = 150,\n    color = alpha(\"#e49635\", .5),\n    font = \"Georgia\",\n    gravity = \"north\",\n    location = \"+0+300\"\n  ) %>% \n  image_annotate(\n    \"Ukraine\",\n    size = 300,\n    color = \"#e49635\",\n    font = \"Georgia\",\n    gravity = \"north\",\n    location = \"+0+500\"\n  ) %>% \n  image_annotate(\n    \"©2023 Ihor Miroshnychenko (https://aranaur.rbind.io)\",\n    size = 100,\n    color = alpha(\"grey20\", .75),\n    font = \"Georgia\",\n    gravity = \"southeast\",\n    location = \"+100+200\"\n  ) %>% \n  image_annotate(\n    \"Data: Esri | Sentinel-2 Land Cover Explorer\",\n    size = 100,\n    color = alpha(\"grey20\", .75),\n    font = \"Georgia\",\n    gravity = \"southeast\",\n    location = \"+100+100\"\n  )\n```\n:::\n\n\nЗбережемо фінальну візуалізацію у файл `3d_ua_land_cover_final_eng.png`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagick::image_write(\n  p, \"3d_ua_land_cover_final_eng.png\"\n)\n```\n:::\n\n\nВ результаті ми отримаємо фінальну візуалізацію земляного покриву України:\n\n[![](img/3d_ua_land_cover_final_eng.png)](https://drive.google.com/file/d/15hk9adj-h9uAdCPXD368yEeB8NqgftUp/view?usp=sharing)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}