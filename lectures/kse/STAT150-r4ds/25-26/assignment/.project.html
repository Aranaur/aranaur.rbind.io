<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ihor Miroshnychenko">

<title>Final Project: Smart City Data Hackathon</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src=".project_files/libs/clipboard/clipboard.min.js"></script>
<script src=".project_files/libs/quarto-html/quarto.js" type="module"></script>
<script src=".project_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src=".project_files/libs/quarto-html/popper.min.js"></script>
<script src=".project_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src=".project_files/libs/quarto-html/anchor.min.js"></script>
<link href=".project_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href=".project_files/libs/quarto-html/quarto-syntax-highlighting-0317528b062ac98fb237a8fea1ccdc2d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src=".project_files/libs/bootstrap/bootstrap.min.js"></script>
<link href=".project_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href=".project_files/libs/bootstrap/bootstrap-265a90d70a4265159d041725066fe607.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Project: Smart City Data Hackathon</h1>
<p class="subtitle lead">STAT 150: R for Data Science</p>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Ihor Miroshnychenko </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Kyiv School of Economics
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="learning-objectives" class="level2">
<h2 class="anchored" data-anchor-id="learning-objectives">ğŸ¯ Learning Objectives</h2>
<p>In this final project, you will work in teams to explore, analyze, and visualize urban data to propose data-driven insights or solutions that could improve the functioning of New York City.</p>
<p>You will combine everything learned in the course â€” from data import and cleaning to visualization, spatial analysis, and reproducible reporting.</p>
</section>
<section id="the-challenge" class="level2">
<h2 class="anchored" data-anchor-id="the-challenge">ğŸ§© The challenge</h2>
<p>The City of New York wants to better understand patterns in mobility, safety, and urban environment. Your task is to use open datasets (such as NYC Taxi data, 311 complaints, weather, or spatial information) to:</p>
<blockquote class="blockquote">
<p>Identify a problem or opportunity for the city, analyze it with data, and propose one or more practical, data-informed solutions.</p>
</blockquote>
<p>Your project should tell a clear story supported by data, code, and visualization.</p>
</section>
<section id="team-format" class="level2">
<h2 class="anchored" data-anchor-id="team-format">ğŸ§‘â€ğŸ¤â€ğŸ§‘ Team format</h2>
<ul>
<li>Work in teams of 2â€“3 students.</li>
<li>Each team chooses its own research question and data sources.</li>
<li>Collaboration and creativity are key â€” technical perfection is less important than originality, storytelling, and insight.</li>
</ul>
</section>
<section id="suggested-data-sources" class="level2">
<h2 class="anchored" data-anchor-id="suggested-data-sources">ğŸ“¦ Suggested data sources</h2>
<p>You are encouraged to combine several datasets. Here are examples (but you may choose others):</p>
<p><strong>Core dataset</strong></p>
<ul>
<li>NYC Taxi &amp; Limousine Commission Trip Data<br> <a href="https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page" class="uri">https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page</a></li>
</ul>
<p><strong>Additional layers (choose 1â€“2+)</strong></p>
<ul>
<li>Weather data â€” NOAA, Open-Meteo API, or other public APIs</li>
<li>311 Service Requests â€” NYC Open Data Portal</li>
<li>Traffic volume, accidents, or speed data</li>
<li>Public transportation, bike sharing (CitiBike), or parking data</li>
<li>Neighborhood demographics or land use</li>
<li>Spatial data â€” borough boundaries, taxi zones, street networks</li>
</ul>
</section>
<section id="what-your-project-should-include" class="level2">
<h2 class="anchored" data-anchor-id="what-your-project-should-include">ğŸ—ºï¸ What your project should include</h2>
<ol type="1">
<li>Data import and integration
<ul>
<li>Combine at least two independent datasets (e.g.&nbsp;taxi + weather, or taxi + 311 complaints).</li>
<li>Use advanced import tools (arrow, duckdb, polars, or API access).</li>
</ul></li>
<li>Data transformation and exploration
<ul>
<li>Clean and summarize data.</li>
<li>Use dplyr, sf, or polars for efficient manipulation.</li>
</ul></li>
<li>Spatial or temporal visualization
<ul>
<li>Create at least one map or time series plot.</li>
<li>Use ggplot2, sf, or leaflet.</li>
</ul></li>
<li>Insights and recommendations
<ul>
<li>Describe findings clearly.</li>
<li>Propose 1â€“2 potential solutions, policies, or improvements for the city.</li>
</ul></li>
<li>Reproducibility and storytelling
<ul>
<li>Document your process in a Quarto report.</li>
<li>Include code, figures, and narrative in a cohesive story.</li>
</ul></li>
</ol>
</section>
<section id="examples-of-possible-directions" class="level2">
<h2 class="anchored" data-anchor-id="examples-of-possible-directions">ğŸŒŸ Examples of possible directions</h2>
<ul>
<li>ğŸ•’ Mobility efficiency: â€œHow do traffic jams and weather affect trip duration?â€</li>
<li>ğŸ’° Economic behavior: â€œWhich neighborhoods have the highest average tips and why?â€</li>
<li>ğŸ§­ Accessibility: â€œWhere are the underserved zones with poor transport connectivity?â€</li>
<li>ğŸŒ³ Sustainability: â€œHow can the city optimize taxi demand to reduce COâ‚‚ emissions?â€</li>
<li>ğŸ§¹ Urban services: â€œAre 311 complaints correlated with low taxi activity or certain areas?â€</li>
<li>ğŸ—ºï¸ Safety: â€œMapping taxi accident locations and suggesting safer routes.â€</li>
</ul>
</section>
<section id="submission" class="level2">
<h2 class="anchored" data-anchor-id="submission">ğŸ“¤ Submission</h2>
<p>Each team must submit:</p>
<ol type="1">
<li>A Quarto project (one .qmd or multi-file report) including:
<ul>
<li>Introduction: research question and motivation.</li>
<li>Data import and cleaning process.</li>
<li>Analysis, visualization, and interpretation.</li>
<li>Policy or design recommendations.</li>
</ul></li>
<li>A short presentation (5â€“7 minutes) during the hackathon session:
<ul>
<li>Tell your story visually.</li>
<li>Focus on key insights and proposed solutions.</li>
</ul></li>
<li>Link to your published Quarto report (on Quarto Pub or GitHub Pages).</li>
</ol>
</section>
<section id="final-note" class="level2">
<h2 class="anchored" data-anchor-id="final-note">ğŸ§­ Final note</h2>
<p>This project is your opportunity to think like data scientists working for a city â€” where code meets impact. Be bold, creative, and analytical. Surprise us with something the data hides!</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>