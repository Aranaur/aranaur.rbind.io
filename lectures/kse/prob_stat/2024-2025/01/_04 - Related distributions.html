<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Related distributions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="_04 - Related distributions_files/libs/clipboard/clipboard.min.js"></script>
<script src="_04 - Related distributions_files/libs/quarto-html/quarto.js"></script>
<script src="_04 - Related distributions_files/libs/quarto-html/popper.min.js"></script>
<script src="_04 - Related distributions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_04 - Related distributions_files/libs/quarto-html/anchor.min.js"></script>
<link href="_04 - Related distributions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_04 - Related distributions_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_04 - Related distributions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_04 - Related distributions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_04 - Related distributions_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#approximating-a-binomial-to-the-normal" id="toc-approximating-a-binomial-to-the-normal" class="nav-link active" data-scroll-target="#approximating-a-binomial-to-the-normal"><span class="header-section-number">1</span> Approximating a binomial to the normal</a></li>
  <li><a href="#simulating-from-the-binomial-and-the-normal" id="toc-simulating-from-the-binomial-and-the-normal" class="nav-link" data-scroll-target="#simulating-from-the-binomial-and-the-normal"><span class="header-section-number">2</span> Simulating from the binomial and the normal</a></li>
  <li><a href="#comparing-the-cumulative-density-of-the-binomial" id="toc-comparing-the-cumulative-density-of-the-binomial" class="nav-link" data-scroll-target="#comparing-the-cumulative-density-of-the-binomial"><span class="header-section-number">3</span> Comparing the cumulative density of the binomial</a></li>
  <li><a href="#comparing-the-distributions-of-the-normal-and-binomial-for-low-n" id="toc-comparing-the-distributions-of-the-normal-and-binomial-for-low-n" class="nav-link" data-scroll-target="#comparing-the-distributions-of-the-normal-and-binomial-for-low-n"><span class="header-section-number">4</span> Comparing the distributions of the normal and binomial for low n</a></li>
  <li><a href="#approximating-a-binomial-with-a-poisson" id="toc-approximating-a-binomial-with-a-poisson" class="nav-link" data-scroll-target="#approximating-a-binomial-with-a-poisson"><span class="header-section-number">5</span> Approximating a binomial with a Poisson</a></li>
  <li><a href="#simulating-from-a-poisson-and-a-binomial" id="toc-simulating-from-a-poisson-and-a-binomial" class="nav-link" data-scroll-target="#simulating-from-a-poisson-and-a-binomial"><span class="header-section-number">6</span> Simulating from a Poisson and a binomial</a></li>
  <li><a href="#density-of-the-poisson-distribution" id="toc-density-of-the-poisson-distribution" class="nav-link" data-scroll-target="#density-of-the-poisson-distribution"><span class="header-section-number">7</span> Density of the Poisson distribution</a></li>
  <li><a href="#sum-of-two-poisson-variables" id="toc-sum-of-two-poisson-variables" class="nav-link" data-scroll-target="#sum-of-two-poisson-variables"><span class="header-section-number">8</span> Sum of two Poisson variables</a></li>
  <li><a href="#waiting-for-first-coin-flip" id="toc-waiting-for-first-coin-flip" class="nav-link" data-scroll-target="#waiting-for-first-coin-flip"><span class="header-section-number">9</span> Waiting for first coin flip</a></li>
  <li><a href="#using-replicate-for-simulation" id="toc-using-replicate-for-simulation" class="nav-link" data-scroll-target="#using-replicate-for-simulation"><span class="header-section-number">10</span> Using <code>replicate()</code> for simulation</a></li>
  <li><a href="#simulating-from-the-geometric-distribution" id="toc-simulating-from-the-geometric-distribution" class="nav-link" data-scroll-target="#simulating-from-the-geometric-distribution"><span class="header-section-number">11</span> Simulating from the geometric distribution</a></li>
  <li><a href="#probability-of-a-machine-lasting-x-days" id="toc-probability-of-a-machine-lasting-x-days" class="nav-link" data-scroll-target="#probability-of-a-machine-lasting-x-days"><span class="header-section-number">12</span> Probability of a machine lasting X days</a></li>
  <li><a href="#graphing-the-probability-that-a-machine-still-works" id="toc-graphing-the-probability-that-a-machine-still-works" class="nav-link" data-scroll-target="#graphing-the-probability-that-a-machine-still-works"><span class="header-section-number">13</span> Graphing the probability that a machine still works</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Related distributions</h1>
<p class="subtitle lead">Probability and Statistics</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="approximating-a-binomial-to-the-normal" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Approximating a binomial to the normal</h1>
<p>Suppose you flipped 1000 coins, each with a 20% chance of being heads. What would be the mean and variance of the binomial distribution?</p>
<ul>
<li>Mean 1000; variance 200</li>
<li>Mean 200; variance 200</li>
<li>Mean 200; variance 160</li>
<li>Mean 160; variance 160</li>
</ul>
</section>
<section id="simulating-from-the-binomial-and-the-normal" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Simulating from the binomial and the normal</h1>
<p>In this exercise you’ll see for yourself whether the normal is a reasonable approximation to the binomial by simulating large samples from the binomial distribution and its normal approximation and comparing their histograms.</p>
<ul>
<li>Generate 100,000 draws from the Binomial(1000, .2) distribution. Save this as <code>binom_sample.</code></li>
<li>Generate 100,000 draws from the normal distribution that approximates this binomial distribution, using the <code>rnorm()</code> function. (Remember that <code>rnorm()</code> takes the mean and the standard deviation, which is the square root of the variance). Save this as <code>normal_sample</code>.</li>
<li>Compare the two distributions with the <code>compare_histograms()</code> function. (Remember that this takes two arguments: the first and second vectors to compare).</li>
</ul>
<p>Code for the <code>compare_histograms()</code> function is provided below:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>compare_histograms <span class="ot">&lt;-</span> <span class="cf">function</span>(variable1, variable2) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">value =</span> variable1, <span class="at">variable =</span> <span class="st">"Variable 1"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">value =</span> variable2, <span class="at">variable =</span> <span class="st">"Variable 2"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">rbind</span>(x, y), <span class="fu">aes</span>(value)) <span class="sc">+</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_histogram</span>(<span class="at">bins =</span> <span class="dv">30</span>) <span class="sc">+</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span> variable, <span class="at">nrow =</span> <span class="dv">2</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="comparing-the-cumulative-density-of-the-binomial" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Comparing the cumulative density of the binomial</h1>
<p>If you flip 1000 coins that each have a 20% chance of being heads, what is the probability you would get 190 heads or fewer?</p>
<p>You’ll get similar answers if you solve this with the binomial or its normal approximation. In this exercise, you’ll solve it both ways, using both simulation and exact calculation.</p>
<ul>
<li>Use the simulated <code>binom_sample</code> (provided) from the last exercise to estimate the probability of getting 190 or fewer heads.</li>
<li>Use the simulated <code>normal_sample</code> to estimate the probability of getting 190 or fewer heads.</li>
<li>Calculate the exact probability of the binomial being &lt;= 190 with <code>pbinom()</code>.</li>
<li>Calculate the exact probability of the normal being &lt;= 190 with <code>pnorm()</code>.</li>
</ul>
</section>
<section id="comparing-the-distributions-of-the-normal-and-binomial-for-low-n" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Comparing the distributions of the normal and binomial for low n</h1>
<p>When we flip a <em>lot</em> of coins, it looks like the normal distribution is a pretty close approximation. What about when we flip only 10 coins, each still having a 20% chance of coming up heads? Is the normal still a good approximation?</p>
<ul>
<li>Generate 100,000 draws from the Binomial(10, .2) distribution. Save this as <code>binom_sample.</code></li>
<li>Generate 100,000 draws from the normal distribution that approximates this binomial distribution, using the <code>rnorm()</code> function. Save this as <code>normal_sample</code>.</li>
<li>Compare the two distributions with the <code>compare_histograms()</code> function. (Remember that this takes two arguments: the two samples that are to be compared).</li>
</ul>
</section>
<section id="approximating-a-binomial-with-a-poisson" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Approximating a binomial with a Poisson</h1>
<p>If you were drawing from a binomial with size = 1000 and p = .002, what would be the mean of the Poisson approximation?</p>
<ul>
<li>1</li>
<li><strong>2</strong></li>
<li>4</li>
<li>20</li>
</ul>
</section>
<section id="simulating-from-a-poisson-and-a-binomial" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Simulating from a Poisson and a binomial</h1>
<p>If we were flipping 100,000 coins that each have a .2% chance of coming up heads, you could use a Poisson(2) distribution to approximate it. Let’s check that through simulation.</p>
<ul>
<li>Generate 100,000 draws from the Binomial(1000, .002) distribution. Save it as <code>binom_sample</code>.</li>
<li>Generate 100,000 draws from the Poisson distribution that approximates this binomial distribution, using the <code>rpois()</code> function. Save it as <code>poisson_sample</code>.</li>
<li>Compare the two distributions with the compare_histograms() function. (Remember that this takes two arguments: the two samples that are to be compared).</li>
</ul>
</section>
<section id="density-of-the-poisson-distribution" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Density of the Poisson distribution</h1>
<p>In this exercise you’ll find the probability that a Poisson random variable will be equal to zero by simulating and using the <code>dpois()</code> function, which gives an exact answer.</p>
<ul>
<li>Simulate 100,000 draws from a Poisson distribution with a mean of 2.</li>
<li>Use this simulation to estimate the probability that a draw from this Poisson distribution will be 0.</li>
<li>Find the exact probability that a draw from a Poisson(2) distribution is zero, using the <code>dpois()</code> function.</li>
</ul>
</section>
<section id="sum-of-two-poisson-variables" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Sum of two Poisson variables</h1>
<p>One of the useful properties of the Poisson distribution is that when you add multiple Poisson distributions together, the result is also a Poisson distribution.</p>
<p>Here you’ll generate two random Poisson variables to test this.</p>
<ul>
<li>Simulate 100,000 draws from the Poisson(1) distribution, saving them as <code>X</code>.</li>
<li>Simulate 100,000 draws separately from the Poisson(2) distribution, and save them as <code>Y</code>.</li>
<li>Add <code>X</code> and <code>Y</code> together to create a variable <code>Z</code>.</li>
<li>We expect <code>Z</code> to follow a Poisson(3) distribution. Use the <code>compare_histograms</code> function to compare <code>Z</code> to 100,000 draws from a Poisson(3) distribution.</li>
</ul>
</section>
<section id="waiting-for-first-coin-flip" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Waiting for first coin flip</h1>
<p>You’ll start by simulating a series of coin flips, and “waiting” for the first heads.</p>
<ul>
<li>Simulate 100 instances of flipping a single coin with a 20% chance of heads, and save it as the variable <code>flips.</code> (Thus, <code>flips</code> should be a vector of length 100).</li>
<li>Use <code>which()</code> to find the first case where a coin resulted in heads.</li>
</ul>
</section>
<section id="using-replicate-for-simulation" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> Using <code>replicate()</code> for simulation</h1>
<p>Use the <code>replicate()</code> function to simulate 100,000 trials of waiting for the first heads after flipping coins with 20% chance of heads. Plot a histogram of this simulation by calling <code>qplot()</code>.</p>
<ul>
<li>Use <code>replicate()</code> to simulate 100,000 geometric trials. Copy and paste the expression given to you as your second argument to <code>replicate()</code>.</li>
<li>Plot a histogram by calling <code>qplot()</code> on the replications.</li>
</ul>
</section>
<section id="simulating-from-the-geometric-distribution" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> Simulating from the geometric distribution</h1>
<p>In this exercise you’ll compare your <code>replications</code> with the output of <code>rgeom()</code>.</p>
<p>Use the function <code>rgeom()</code> to simulate 100,000 draws from a geometric distributions with probability .2. Save this as <code>geom_sample</code>. Compare <code>replications</code> and <code>geom_sample</code> with the <code>compare_histograms()</code> function.</p>
</section>
<section id="probability-of-a-machine-lasting-x-days" class="level1" data-number="12">
<h1 data-number="12"><span class="header-section-number">12</span> Probability of a machine lasting X days</h1>
<p>A new machine arrives in a factory. This type of machine is very unreliable: every day, it has a 10% chance of breaking permanently. How long would you expect it to last?</p>
<p>Notice that this is described by the cumulative distribution of the geometric distribution, and therefore the <code>pgeom()</code> function. <code>pgeom(X, .1)</code> would describe the probability that there are X working days before the day it breaks (that is, that it breaks on day X + 1).</p>
<ul>
<li>Use <code>pgeom()</code> to find the probability that the machine breaks on the 5th day or earlier.</li>
<li>Use <code>pgeom()</code> to find the probability that the machine is <em>still working</em> by the end of the 20th day.</li>
</ul>
</section>
<section id="graphing-the-probability-that-a-machine-still-works" class="level1" data-number="13">
<h1 data-number="13"><span class="header-section-number">13</span> Graphing the probability that a machine still works</h1>
<p>If you were a supervisor at the factory with the unreliable machine, you might want to understand how likely the machine is to keep working over time. In this exercise, you’ll plot the probability that the machine is still working across the first 30 days.</p>
<ul>
<li>Calculate a vector of probabilities of whether the machine is <em>still working</em> on each day from day 1 to 30, and save it as <code>still_working.</code> You can do this with a single call to <code>pgeom()</code> by passing in a vector of numbers as the first argument. The machine has a 10% chance of breaking each day.</li>
<li>Run the command <code>qplot(still_working)</code> to graph the probability of the machine still working on each of the first 30 days, with the day on the x-axis and the probability on the y-axis.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>