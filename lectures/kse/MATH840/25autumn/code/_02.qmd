---
title: "Time series visualization: Ukraine electricity generation"
format: html
execute: 
  warning: false
  message: false
---

## Imports

```{python}
import warnings
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import altair as alt

from cycler import cycler
from statsforecast import StatsForecast
from utilsforecast.preprocessing import fill_gaps
from utilsforecast.plotting import plot_series

def setup_plotting_styles():
    """
    Встановлює єдиний стиль для всіх графіків у проєкті.
    """
    sns.set_style("whitegrid")
    
    plt.style.use("ggplot")

    mpl.rcParams.update({
        'axes.grid': True,
        'axes.grid.which': 'both',
        'grid.color': '#cccccc',
        'grid.linestyle': '--',
        'grid.linewidth': 0.5,
        'figure.figsize': (12, 6),
        'font.size': 12,
        'axes.titlesize': 'large',
        'axes.labelsize': 'medium'
    })
    
    custom_cycler = cycler(color=["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"])
    mpl.rcParams['axes.prop_cycle'] = custom_cycler

setup_plotting_styles()
```

## Load Ukraine electricity generation data

Weather data

```{python}
weather_df = pd.read_csv(
    'https://raw.githubusercontent.com/Aranaur/aranaur.rbind.io/main/datasets/energy_ua/energy_weather_ua_2016_2019.csv'
    )
    .drop(columns=['Heneratsia'])

# change columns names
weather_df.columns = [
    'ds',
    'w_cloudiness_percent',
    'w_temperature_celsius',
    'w_wind_speed_m_s',
    'w_pressure_hpa',
    'w_humidity_percent',
    'w_sundial_hours',
    'w_air_density_kg_m3',
    ]

weather_df
```

Electricity generation data
```{python}
electricity_df = pd.read_csv(
    'https://raw.githubusercontent.com/Aranaur/aranaur.rbind.io/main/datasets/energy_ua/energy_ua_2014_2021.csv'
)

electricity_df.columns = [
    'ds',
    'nuclear_generation_mwh',
    'total_consumption_mwh',
    'pump_storage_generation_mwh',
    'pump_storage_consumption_mwh',
    'hydro_generation_mwh',
    'cogeneration_generation_mwh',
    'thermal_generation_mwh',
    'export_blr_rus_mwh',
    'export_eu_mwh',
    'export_mld_mwh',
    'renewable_generation_mwh'
]

electricity_df
```

Merge datasets

```{python}
df = pd.merge(
    electricity_df,
    weather_df,
    on='ds',
    how='left'
)
df['ds'] = pd.to_datetime(df['ds'])
df
```

```{python}
df.info()
```

Pivot data to long format

```{python}
df_h = df.melt(
    id_vars=['ds'],
    var_name='unique_id',
    value_name='y'
)
df_h
```

New datasets with different time resolutions with aggregation (sum), but if variable starts with "w_" then mean aggregation

```{python}
def resample_data(df, freq_code):
    """
    Агрегує дані до заданої частоти.
    Використовує суму для енергетичних метрик і середнє для погодних.
    """
    # Групуємо та агрегуємо
    resampled_df = df.groupby(['unique_id', pd.Grouper(key='ds', freq=freq_code)])['y'].agg(['sum', 'mean']).reset_index()
    
    # Визначаємо правильне значення на основі типу метрики
    is_weather_metric = resampled_df['unique_id'].str.startswith('w_')
    resampled_df['y'] = np.where(
        is_weather_metric,
        resampled_df['mean'],  # Середнє для погоди
        resampled_df['sum']     # Сума для енергетики
    )
    
    # Видаляємо проміжні стовпці
    return resampled_df.drop(columns=['sum', 'mean'])

# Тепер викликаємо функцію для кожної частоти
df_d = resample_data(df_h, 'D')   # День
df_w = resample_data(df_h, 'W')   # Тиждень
df_m = resample_data(df_h, 'ME')  # Кінець місяця
df_q = resample_data(df_h, 'QE')  # Кінець кварталу
```

## Time plots

```{python}
plot_series(
    df_h,
    max_ids=df_h['unique_id'].nunique()
)
```

Hourly data

```{python}
StatsForecast.plot(
    df_h,
    unique_ids=['nuclear_generation_mwh', 'w_temperature_celsius']
)
```



Daily data
```{python}
StatsForecast.plot(
    df_d,
    unique_ids=['nuclear_generation_mwh', 'w_temperature_celsius']
)
```

Weekly data

```{python}
StatsForecast.plot(
    df_w,
    unique_ids=['nuclear_generation_mwh', 'w_temperature_celsius']
)
```

Monthly data

```{python}
StatsForecast.plot(
    df_m,
    unique_ids=['nuclear_generation_mwh', 'w_temperature_celsius']
)
```

Quarterly data

```{python}
StatsForecast.plot(
    df_q,
    unique_ids=['nuclear_generation_mwh', 'w_temperature_celsius']
)
```

## Seasonal plots

Monthly seasonal plot for nuclear generation

```{python}
# remove october 2021 partial data
df_m = df_m[~((df_m['ds'] >= '2021-10-01') & (df_m['ds'] < '2021-11-01'))]

df_m['month_name'] = df_m['ds'].dt.month_name()
df_m['year'] = df_m['ds'].dt.year
df_m['month_num'] = df_m['ds'].dt.month

unique_years = df_m['year'].unique()
year_palette = sns.color_palette("husl", len(unique_years))

fig, ax = plt.subplots()
sns.lineplot(
    data=df_m[df_m['unique_id'] == 'nuclear_generation_mwh'],
    x='month_num',
    y='y',
    hue='year',
    palette=year_palette,
    legend=False,
    ax=ax
)
ax.set_title('Seasonal Plot - Nuclear Generation (Monthly)')
ax.set_xlabel('Month')
ax.set_ylabel('Generation (MWh)')
ax.set_xticks(
    range(1, 13),
    ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
)

min_year = unique_years.min()

for year, subset in df_m[df_m['unique_id'] == 'nuclear_generation_mwh'].groupby('year'):
    ax.text(
        subset['month_num'].iloc[-1],
        subset['y'].iloc[-1],
        str(year),
        fontsize=9,
        weight='bold',
        color=year_palette[list(unique_years).index(year)]
    )
```

```{python}
import seaborn as sns
import matplotlib.pyplot as plt

# --- Крок 1: Підготовка даних (виконується один раз) ---
# Робимо копію, щоб уникнути SettingWithCopyWarning
df_monthly_clean = df_m[df_m['ds'].dt.year != 2021].copy()

# --- Крок 2: Створюємо функцію для побудови сезонних графіків ---

def plot_seasonal(
    data: pd.DataFrame, 
    metric_id: str, 
    title: str,
    y_label: str,
    ax: plt.Axes = None
) -> plt.Axes:
    """
    Будує сезонний графік для обраної метрики по місяцях.
    
    Args:
        data: DataFrame з даними.
        metric_id: Назва метрики (unique_id), яку потрібно візуалізувати.
        title: Заголовок графіка.
        y_label: Підпис осі Y.
        ax: Існуючі осі Matplotlib для малювання (необов'язково).

    Returns:
        Осі Matplotlib з графіком.
    """
    # 1. Фільтруємо дані для конкретної метрики
    plot_data = data[data['unique_id'] == metric_id].assign(
        year=lambda d: d['ds'].dt.year,
        month_num=lambda d: d['ds'].dt.month
    )
    
    # 2. Створюємо палітру та ефективну мапу "рік -> колір"
    unique_years = sorted(plot_data['year'].unique())
    palette = sns.color_palette("viridis", len(unique_years))
    color_map = dict(zip(unique_years, palette))

    # 3. Створюємо фігуру, якщо вона не була передана
    if ax is None:
        fig, ax = plt.subplots(figsize=(14, 7))

    # 4. Будуємо основний графік
    sns.lineplot(
        data=plot_data,
        x='month_num',
        y='y',
        hue='year',
        palette=color_map,
        legend=False,
        ax=ax
    )

    # 5. Налаштовуємо вигляд графіка
    ax.set_title(title, fontsize=16)
    ax.set_xlabel('Місяць', fontsize=12)
    ax.set_ylabel(y_label, fontsize=12)
    ax.set_xticks(ticks=range(1, 13))
    ax.set_xticklabels(['Січ', 'Лют', 'Бер', 'Кві', 'Тра', 'Чер', 'Лип', 'Сер', 'Вер', 'Жов', 'Лис', 'Гру'])
    ax.grid(True, linestyle='--', alpha=0.6)

    # 6. Додаємо текстові мітки для кожного року (більш ефективно)
    for year, group in plot_data.groupby('year'):
        last_point = group.iloc[-1]
        ax.text(
            last_point['month_num'] + 0.1,  # Невеликий відступ для читабельності
            last_point['y'],
            year,
            color=color_map[year],
            fontsize=10,
            weight='bold',
            ha='left',
            va='center'
        )
        
    return ax

# --- Крок 3: Використовуємо нашу нову функцію! ---
plot_seasonal(
    data=df_monthly_clean,
    metric_id='nuclear_generation_mwh',
    title='Сезонність генерації АЕС (помісячно)',
    y_label='Генерація (МВт·год)'
)
plt.show()

# Тепер легко побудувати графік для іншої метрики!
plot_seasonal(
    data=df_monthly_clean,
    metric_id='total_consumption_mwh',
    title='Сезонність загального споживання (помісячно)',
    y_label='Споживання (МВт·год)'
)
plt.show()
```

Same interactive plot with Altair

```{python}
import altair as alt
import pandas as pd

# (Припускаємо, що df_m вже існує і підготовлений)
# Наприклад, очищений від даних за 2021 рік
# df_m = df_m[df_m['ds'].dt.year != 2021].copy()


def create_altair_seasonal_plot(
    data: pd.DataFrame, 
    metric_id: str, 
    title: str,
    y_axis_title: str
) -> alt.Chart:
    """
    Створює інтерактивний сезонний графік за допомогою Altair.
    
    Args:
        data: DataFrame з даними у довгому форматі.
        metric_id: Назва метрики (unique_id) для візуалізації.
        title: Заголовок графіка.
        y_axis_title: Підпис осі Y.

    Returns:
        Об'єкт Altair Chart.
    """
    # 1. Фільтруємо дані для потрібної метрики
    plot_data = data[data['unique_id'] == metric_id]
    
    # 2. Створюємо графік
    chart = alt.Chart(plot_data).mark_line(
        point=True, # Додаємо точки для кращої візуалізації даних
        opacity=0.8
    ).encode(
        # 3. Використовуємо :O (Ordinal) для місяців, щоб зберегти їх порядок
        x=alt.X('month(ds):O', title='Місяць'),
        
        # 4. Використовуємо динамічний заголовок для осі Y
        y=alt.Y('y:Q', title=y_axis_title, axis=alt.Axis(format='~s')), # Формат 's' для скорочень (K, M)
        
        # 5. Кодуємо колір за роком
        color=alt.Color('year(ds):N', title='Рік'),
        
        # 6. Створюємо більш інформативні підказки (tooltips)
        tooltip=[
            alt.Tooltip('year(ds):O', title='Рік'),
            alt.Tooltip('month(ds):T', title='Місяць', format='%B'), # Показуємо повну назву місяця
            alt.Tooltip('y:Q', title=y_axis_title, format=',.0f') # Форматуємо число
        ]
    ).properties(
        title=title,
        width=700,
        height=400
    ).interactive() # Дозволяє масштабування та панорамування
    
    return chart

# --- Використання функції ---

# 1. Графік для генерації АЕС
nuclear_plot = create_altair_seasonal_plot(
    data=df_m,
    metric_id='nuclear_generation_mwh',
    title='Сезонність генерації АЕС (помісячно)',
    y_axis_title='Генерація (МВт·год)'
)
# nuclear_plot.display() # Розкоментуйте, щоб показати в блокноті

# 2. Тепер дуже легко створити такий самий графік для іншої метрики
consumption_plot = create_altair_seasonal_plot(
    data=df_m,
    metric_id='total_consumption_mwh',
    title='Сезонність загального споживання (помісячно)',
    y_axis_title='Споживання (МВт·год)'
)
# consumption_plot.display()

# Ви можете легко об'єднати їх для порівняння
# (nuclear_plot | consumption_plot)
nuclear_plot
```

```{python}
alt.Chart(
    df_m[df_m['unique_id'] == 'nuclear_generation_mwh']
).mark_line().encode(
    x=alt.X('month(ds):N', title='Month'),
    y=alt.Y('y:Q', title='Generation (MWh)'),
    color=alt.Color('year(ds):N', title='Year'),
    tooltip=['year(ds):N', 'month(ds):N', 'y:Q']
).properties(
    title='Seasonal Plot - Nuclear Generation (Monthly)'
).interactive()
```

Hourly seasonal plot for nuclear generation

```{python}
def plot_daily_profile(
    data: pd.DataFrame, 
    metric_id: str, 
    title: str,
    y_label: str,
    ax: plt.Axes = None
) -> plt.Axes:
    """
    Будує агрегований добовий профіль (середнє + 95% довірчий інтервал)
    для обраної метрики.
    
    Args:
        data: DataFrame з погодинними даними.
        metric_id: Назва метрики (unique_id) для візуалізації.
        title: Заголовок графіка.
        y_label: Підпис осі Y.
        ax: Існуючі осі Matplotlib для малювання (необов'язково).
        
    Returns:
        Осі Matplotlib з графіком.
    """
    # 1. Фільтруємо дані та створюємо числовий стовпець 'hour'
    plot_data = data[data['unique_id'] == metric_id].copy()
    plot_data['hour'] = plot_data['ds'].dt.hour
    
    # 2. Створюємо фігуру, якщо потрібно
    if ax is None:
        fig, ax = plt.subplots(figsize=(12, 6))

    # 3. Будуємо графік. Seaborn автоматично розрахує середнє 
    #    і 95% довірчий інтервал для 'y' для кожної години.
    sns.lineplot(
        data=plot_data,
        x='hour',
        y='y',
        ax=ax,
        linewidth=2.5,
        color='#005A9C' # Приклад кольору
    )
    
    # 4. Налаштовуємо вигляд графіка
    ax.set_title(title, fontsize=16, pad=20)
    ax.set_xlabel('Година доби', fontsize=12)
    ax.set_ylabel(y_label, fontsize=12)
    ax.grid(True, linestyle='--', alpha=0.6)
    
    # 5. Спрощуємо налаштування осі X, оскільки вона тепер числова
    ax.set_xticks(range(0, 25, 2)) # Мітки кожні 2 години
    ax.set_xlim(0, 23) # Обмежуємо вісь 24 годинами
    
    return ax

# --- Використання функції ---

# 1. Будуємо профіль для гідрогенерації
plot_daily_profile(
    data=df_h,
    metric_id='hydro_generation_mwh',
    title='Типовий добовий профіль генерації ГЕС',
    y_label='Генерація (МВт·год)'
)
plt.show()

# 2. Легко будуємо такий самий графік для температури
plot_daily_profile(
    data=df_h,
    metric_id='w_temperature_celsius',
    title='Типовий добовий профіль температури',
    y_label='Температура (°C)'
)
plt.show()
```

Аlternative hourly seasonal plot for hydro generation

```{python}
df_h['hour-minute'] = df_h['ds'].dt.strftime('%H:%M:%S')
df_h['day'] = df_h['ds'].dt.date

fig, ax = plt.subplots()
sns.lineplot(
    data=df_h[df_h['unique_id'] == 'hydro_generation_mwh'],
    x='hour-minute',
    y='y',
    hue='day',
    legend=False,
    ax=ax,
    palette="husl"
)

unique_ticks = df_h['hour-minute'].unique()
ticks_to_plot = unique_ticks[::2]

ax.set_xticks(ticks=range(0, len(unique_ticks), 2), labels=ticks_to_plot,
    rotation=45)
ax.set_title('Seasonal Plot - Hydro Generation (Hourly)')
ax.set_xlabel('Hour of Day')
ax.set_ylabel('Generation (MWh)')
```

Seasonal plot showing weekly seasonal patterns for nuclear generation

```{python}
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

def plot_weekly_seasonal(
    data: pd.DataFrame, 
    metric_id: str, 
    title: str,
    y_label: str,
    ax: plt.Axes = None
) -> plt.Axes:
    """
    Будує сезонний графік для обраної метрики по тижнях року.
    
    Args:
        data: DataFrame з даними.
        metric_id: Назва метрики (unique_id) для візуалізації.
        title: Заголовок графіка.
        y_label: Підпис осі Y.
        ax: Існуючі осі Matplotlib для малювання (необов'язково).

    Returns:
        Осі Matplotlib з графіком.
    """
    # 1. Фільтруємо дані та створюємо необхідні стовпці за допомогою .assign()
    plot_data = data[data['unique_id'] == metric_id].assign(
        year=lambda d: d['ds'].dt.year,
        week_num=lambda d: d['ds'].dt.isocalendar().week
    )
    
    # 2. Створюємо палітру та ефективну мапу "рік -> колір"
    unique_years = sorted(plot_data['year'].unique())
    palette = sns.color_palette("viridis", len(unique_years))
    color_map = dict(zip(unique_years, palette))

    # 3. Створюємо фігуру, якщо вона не була передана
    if ax is None:
        fig, ax = plt.subplots(figsize=(14, 7))

    # 4. Будуємо основний графік
    sns.lineplot(
        data=plot_data,
        x='week_num',
        y='y',
        hue='year',
        palette=color_map,
        legend=False,
        ax=ax
    )

    # 5. Налаштовуємо вигляд графіка
    ax.set_title(title, fontsize=16)
    ax.set_xlabel('Тиждень року', fontsize=12)
    ax.set_ylabel(y_label, fontsize=12)
    ax.grid(True, linestyle='--', alpha=0.6)
    ax.set_xlim(1, 53) # Встановлюємо чіткі межі для осі X
    ax.set_xticks(range(1, 53, 4)) # Мітки кожні 4 тижні

    # 6. Додаємо текстові мітки для кожного року (ефективно та чисто)
    for year, group in plot_data.groupby('year'):
        last_point = group.iloc[-1]
        ax.text(
            last_point['week_num'] + 0.5, # Невеликий відступ для читабельності
            last_point['y'],
            year,
            color=color_map[year],
            fontsize=10,
            weight='bold',
            ha='left',
      
        )
        
    return ax

# --- Використання нової функції ---

# 1. Будуємо графік для генерації АЕС
plot_weekly_seasonal(
    data=df_d,
    metric_id='nuclear_generation_mwh',
    title='Сезонність генерації АЕС (потижнево)',
    y_label='Генерація (МВт·год)'
)
plt.show()

# 2. Тепер легко побудувати такий самий графік для загального споживання
plot_weekly_seasonal(
    data=df_d,
    metric_id='total_consumption_mwh',
    title='Сезонність загального споживання (потижнево)',
    y_label='Споживання (МВт·год)'
)
plt.show()
```

Seasonal plot showing yearly seasonal patterns for nuclear generation

```{python}
df_d['day_of_year'] = df_d['ds'].dt.dayofyear
df_d['year'] = df_d['ds'].dt.year

unique_years = df_d['year'].unique()
pallette = sns.color_palette("husl", len(unique_years))
color_map = dict(zip(unique_years, pallette))

fig, ax = plt.subplots()
for year, subset in df_d[df_d['unique_id'] == 'nuclear_generation_mwh'].groupby('year'):
    ax.plot(
        subset['day_of_year'],
        subset['y'],
        label=year,
        color=color_map[year]
    )
ax.set_title('Seasonal Plot - Nuclear Generation (Daily)')
ax.set_xlabel('Day of Year')
ax.set_ylabel('Generation (MWh)')
for year, subset in df_d[df_d['unique_id'] == 'nuclear_generation_mwh'].groupby('year'):
    ax.text(
        subset['day_of_year'].iloc[-1],
        subset['y'].iloc[-1],
        str(year),
        fontsize=9,
        weight='bold',
        color=color_map[year]
    )
fig.show()
```

## Subseries plots

Monthly subseries plot for nuclear generation

```{python}
fig, axes = plt.subplots(nrows=1, ncols=12, sharey=True)
for i, month in enumerate(df_m['ds'].dt.month_name().unique()):
    month_data = df_m.query(
        "unique_id == 'nuclear_generation_mwh' and month_name == @month"
    )
    mean_value = month_data['y'].mean()
    axes[i].plot(
        month_data['year'],
        month_data['y'],
        color='black'
    )
    axes[i].axhline(
        mean_value,
        color='blue',
        linestyle='-',
        linewidth=1,
        label='Mean'
    )
    axes[i].set_title(month)
    axes[i].set_xlabel('')
    axes[i].tick_params(axis='x', rotation=90)
    if i == 0:
        axes[i].set_ylabel('Generation (MWh)')
    else:
        axes[i].set_ylabel('')

fig.suptitle('Subseries Plot - Nuclear Generation (Monthly)', fontsize=16)
fig.text(0.5, -0.05, 'Month', ha='center')
fig.subplots_adjust(wspace=0.2)
```

Or using boxplots

```{python}
fig, ax = plt.subplots()
sns.boxplot(
    data=df_m[df_m['unique_id'] == 'nuclear_generation_mwh'],
    x=df_m['ds'].dt.month_name(),
    y='y',
    order=['January', 'February', 'March', 'April', 'May', 'June',
           'July', 'August', 'September', 'October', 'November', 'December'],
    ax=ax
)
ax.set_title('Subseries Plot - Nuclear Generation (Monthly)')
ax.set_xlabel('Month')
ax.set_ylabel('Generation (MWh)')
```

Or using [`statsmodels.graphics.tsaplots.month_plot`](https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.month_plot.html)

## All variables time plot

```{python}
# unique ids that not start with 'w_'
unique_ids = df_q['unique_id'].unique().tolist()
unique_ids = [uid for uid in unique_ids if not uid.startswith('w_')]
colors = sns.color_palette("husl", len(unique_ids))
fig, ax = plt.subplots()
for i, color in zip(unique_ids, colors):
    subset = df_q.query("unique_id == @i")
    subset.plot(
        x='ds',
        y='y',
        ax=ax,
        label=i,
        color=color
    )
ax.set_title('All Variables Time Plot (Quarterly)')
ax.set_xlabel('Date')
ax.set_ylabel('Generation (MWh)')
fig.show()
```

Seasonal plot for all variables

```{python}
df_q['Quarter'] = 'Q' + df_q['ds'].dt.quarter.astype(str)
df_q['Year'] = df_q['ds'].dt.year
years = sorted(df_q['Year'].unique())
palette = sns.color_palette("husl", len(years))
year_to_color = dict(zip(years, palette))

n_gen = df_q['unique_id'].nunique()

fig, axes = plt.subplots(nrows=n_gen, ncols=1, figsize=(12, n_gen * 3), sharex=True)
for ax, (uid, group) in zip(axes, df_q.groupby('unique_id')):
    for year, subset in group.groupby('Year'):
        ax.plot(
            subset['Quarter'],
            subset['y'],
            label=str(year),
            color=year_to_color[year]
        )
    ax.set_title(f'Subseries Plot - {uid} (Quarterly)')
    ax.set_ylabel('Generation (MWh)')
    ax.legend(title='Year', bbox_to_anchor=(1.05, 1), loc='upper left')
fig.tight_layout()
```

Subseries plot for all variables using lineplot and facets

```{python}
uids = sorted(df_q['unique_id'].unique())
n_uids = len(uids)
quarters = sorted(df_q['Quarter'].unique())

fig, axs = plt.subplots(n_uids, 4, sharex=True, figsize=(12, n_uids * 2.5))
axs = axs.flatten()

for r_idx, (uid, df_uid) in enumerate(df_q.groupby('unique_id', sort=True)):
    y_min, y_max = df_uid['y'].min(), df_uid['y'].max()
    for q_name, df_uid_q in df_uid.groupby('Quarter'):
        c_idx = quarters.index(q_name)
        ax = axs[r_idx * 4 + c_idx]
        df_uid_q.plot(y='y', x='Year', ax=ax, label=None, color='black', marker='o', linestyle='-')
        ax.axhline(df_uid_q['y'].mean(), color='blue')
        ax.set_ylim(y_min, y_max)
        ax.set_xlabel('')
        ax.tick_params(axis='x', rotation=90)
        if ax.get_legend() is not None:
            ax.get_legend().remove()
        ax.set_xticks(df_uid_q['Year'].unique())

for j, q in enumerate(quarters):
    axs[j].set_title(q)

for i, uid in enumerate(uids):
    axs[i * 4 + 3].text(1.02, 0.5, uid, va='center', ha='left', rotation=270, transform=axs[i * 4 + 3].transAxes)

fig.supylabel('Generation (MWh)', va='center', rotation=90)
fig.supxlabel('Year', ha='center')
fig.suptitle('Subseries Plot for All Variables (Quarterly)')
fig.tight_layout()
fig.show()
```

## Scatterplots

Basic scatterplot daily data

```{python}
df_d_pivot = df_d.pivot(
    index='ds',
    columns='unique_id',
    values='y'
).reset_index()

fig, ax = plt.subplots()
sns.scatterplot(
    data=df_d_pivot,
    x='w_temperature_celsius',
    y='total_consumption_mwh',
    ax=ax
)
ax.set_title('Scatterplot: Total Consumption vs Temperature (Daily)')
ax.set_xlabel('Temperature (Celsius)')
ax.set_ylabel('Total Consumption (MWh)')
```

Analog `ggpair` plot with Python using `seaborn` pairplot

```{python}
from scipy.stats import pearsonr

df_for_plot = df.drop(columns=['ds']).dropna()

def corrfunc(x, y, **kws):
    r, pvalue = pearsonr(x, y)
    ax = plt.gca()
    ax.annotate(f"r= \n{r:.2f}{'***' if pvalue < 0.05 else ''}",
                xy=(0.5, 0.5),
                xycoords='axes fraction',
                ha='center', va='center', fontsize=12
    )

g = sns.PairGrid(df_for_plot)
g.map_lower(sns.scatterplot, color='black')
g.map_upper(corrfunc)
g.map_diag(sns.kdeplot, fill=True, color='black')

g.set(xlabel='')

for i, col in enumerate(df_for_plot.columns):
    g.axes[i,0].set_ylabel(col)
    g.axes[-1,i].set_xlabel(col)
```

## Lag plots

```{python}
#| warning: false
#| message: false
df_q_filtered = df_q[df_q['unique_id'] == 'cogeneration_generation_mwh']

for lag in range(1, 10):
    df_q_filtered[f'lag_{lag}'] = df_q_filtered['y'].shift(lag)
lags = [f'lag_{lag}' for lag in range(1, 10)]
lims = [
    np.min([df_q_filtered[lag].min() for lag in lags]),
    np.max([df_q_filtered[lag].max() for lag in lags])
]
fig, axes = plt.subplots(3, 3)
for ax, lag in zip(axes.flatten(), lags):
    ax.scatter(
        df_q_filtered[lag],
        df_q_filtered['y'],
        cmap='viridis',
        c=df_q_filtered['Quarter'].astype('category').cat.codes,
    )
    ax.plot(lims, lims, color='gray', linestyle='--')
    ax.set_title(f'lag {lag.split("_")[1]}')

unique_quarters = sorted(df_q_filtered['Quarter'].unique())
colors = plt.cm.viridis(np.linspace(0, 1, len(unique_quarters)))
handles = [plt.Line2D([0], [0], marker='o', color=color, lw=4) for color in colors]
labels = [f"Q{q}" for q in unique_quarters]
fig.legend(handles, labels, title='Quarter', loc='upper right')
fig.suptitle('Lag Plots - Nuclear Generation (Quarterly)', fontsize=16)
fig.tight_layout()
```

## Autocorrelation plots

ACF tabele

```{python}
import statsmodels.api as sm
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf


acf_df = pd.DataFrame(
    {"Lag": range(10),
     "ACF": sm.tsa.acf(
         df_q[df_q['unique_id'] == 'cogeneration_generation_mwh']['y'],
         nlags=9
     )}
).set_index('Lag')
acf_df[1:]
```

ACF plot quarterly data

```{python}
fig, ax = plt.subplots()
plot_acf(
    df_q[df_q['unique_id'] == 'cogeneration_generation_mwh']['y'],
    lags=16,
    ax=ax,
    zero=False,
    bartlett_confint=False, # disable Bartlett confidence intervals
    auto_ylims=True
)
ax.set_title('Autocorrelation Function - Cogeneration Generation (Quarterly)')
ax.set_xlabel('Lags')
ax.set_ylabel('ACF')
```

ACF plot monthly data

```{python}
fig, ax = plt.subplots()
plot_acf(
    df_m[df_m['unique_id'] == 'cogeneration_generation_mwh']['y'],
    lags=60,
    ax=ax,
    zero=False,
    bartlett_confint=False, # disable Bartlett confidence intervals
    auto_ylims=True
)
ax.set_title('Autocorrelation Function - Cogeneration Generation (Monthly)')
ax.set_xticks(range(0, 61, 5))
ax.set_xlabel('Lags')
ax.set_ylabel('ACF')
```

ACF plot daily data

```{python}
fig, ax = plt.subplots()
plot_acf(
    df_d[df_d['unique_id'] == 'cogeneration_generation_mwh']['y'],
    lags=400,
    ax=ax,
    zero=False,
    bartlett_confint=False, # disable Bartlett confidence intervals
    auto_ylims=True
)
ax.set_title('Autocorrelation Function - Cogeneration Generation (Daily)')
ax.set_xticks(range(0, 121, 10))
ax.set_xlabel('Lags')
ax.set_ylabel('ACF')
```

