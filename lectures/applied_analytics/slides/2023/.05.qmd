---
title: "Python: Регулярні вирази"
title-slide-attributes:
    data-background-iframe: colored-particles/index.html
subtitle: "Прикладна аналітика при розробці IT"
author: "Ігор Мірошниченко"
footer: <a href="https://aranaur.rbind.io/lectures/applied_analytics/">Прикладна аналітика при розробці IT</a>
# date: today
# date-format: iso
institute: КНУ імені Тараса Шевченка, ФІТ
language: _language-ua.yml
format:
  revealjs: 
    theme: [simple, custom.scss]
    logo: fit.png
    chalkboard: true
    slide-number: true
    toc: true
    toc-title: ЗМІСТ
    transition: fade
    mouse-wheel: true
    highlight-style: github
    mainfont: metropolis
    toc-depth: 1
    fig-width: 9
    fig-height: 5
    # auto-stretch: false

from: markdown+emoji

execute: 
  echo: true

jupyter: python3
        
# knitr: 
#   opts_chunk: 
#     echo: true
#     warnings: false
#     message: false
editor_options: 
  chunk_output_type: console
---

# Регулярні вирази {background-iframe="colored-particles/index.html"}

## Регулярні вирази

**Регулярні вирази** (англ. *regular expressions*, *regexes*) - це патерни, які використовуються для знаходження певних комбінацій символів у тексті. 

Наприклад, якщо користувач вводить адресу електронної пошти у вашій програмі, на веб-сайті або в додатку на телефоні, в ідеалі ви хочете мати можливість перевірити, що він дійсно ввів адресу електронної пошти, а не щось інше.

Використовуючи регулярні вирази, ми можемо перевірити, чи = введений текст певному формату. Це дуже корисно, оскільки ви можете використовувати регулярні вирази для перевірки введення користувача, або для пошуку певних комбінацій символів у тексті.

Вони дуже потужні, але в той же час достатньо складні. Якщо ви вперше з ними зіткнулися, то вони здаються дуже незрозумілими. Але якщо ви вже з ними працювали, то ви не зможете без них.

## Звичайний пошук {.smaller}

Для початку розглянемо декілька задач і спробуємо їх вирішити використовуючи більш простий синтаксис, і подивитися, з якими обмеженнями ми зіткнемося.

Створимо файл `validate.py` метою якого є перевірка адреси електронної пошти користувача.

```{.bash filename="Terminal"}
code validate.py
```

Напишемо просту програму, яка буде приймати від користувача адресу електронної пошти і перевіряти, чи вона = певному формату. 

Використаємо метод `strip()` для видалення зайвих пробілів з початку і кінця рядка. Але як перевірити, що введене значення дійсно є валідним для електронної пошти? 

Перша ідея, яка з'являється - це перевірити, чи введений текст містить символ `@`. Якщо так, то ми можемо припустити, що це адреса електронної пошти:

```{python}
#| label: validate-eval-at
#| eval: false

email = input("Введіть email: ").strip()

if "@" in email:
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти
```

Зрозуміло, що така програма не є ідеальною, оскільки ми можемо ввести тільки один або декілька символів `@` і програма буде пропускати такі випадки.

## Звичайний пошук

Наступна ідея - це додати додаткову перевірку, що введений текст містить символ "крапки" (`.`).

Якщо так, то ми можемо припустити, що це адреса електронної пошти. Давайте спробуємо це зробити:

```{python}
#| label: validate-eval-dot
#| eval: false

email = input("Введіть email: ").strip()

if "@" in email and "." in email:
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти
```

## Звичайний пошук

Програма все ще не ідеальна.

Давайте припустимо, що крапка може бути тільки після символа `@`.

Для цього ми можемо поділити введений рядок на дві частини, використовуючи метод `split()` і перевірити, що друга частина містить крапку:

```{python}
#| label: validate-eval-split
#| eval: false

email = input("Введіть email: ").strip()

username, domain = email.split("@")

if username and "." in domain:
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти
```

## Метод `endswith()`

Тепер давайте звузимо сферу застосування цієї програми і будемо шукати валідні адреси навчальних закладів, які мають домен `.edu`.

Для цього ми можемо використати метод `endswith()`:

```{python}
#| label: validate-eval-endswith
#| eval: false

email = input("Введіть email: ").strip()

username, domain = email.split("@")

if username and domain.endswith(".edu"):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: potter@.hogwarts.edu
Валідна адреса електронної пошти
```

Ми можемо продовжувати роботу над цією програмою. В кінцевому підсумку нам доведеться писати багато коду, просто щоб валідувати адресу електронної пошти.

## Бібліотека `re`

В Python є бібліотека для регулярних виразів, яка лаконічно називається `re`. В ній є багато можливостей для визначення, перевірки і заміни шаблонів.

::: {.callout-note}
Документація до бібліотеки `re` доступна за посиланням <https://docs.python.org/3/library/re.html>.
:::

Почнемо з однієї з найбільш універсальних функцій пошуку:

`re.search(pattern, string, flags=0)`:

-  `pattern` - регулярний вираз, який ми шукаємо
-  `string` - рядок, в якому ми шукаємо
-  `flags` - додаткові флаги, які визначають поведінку функції

Ця функція повертає об'єкт, який містить інформацію про знайдений шаблон. Якщо шаблон не знайдено, то функція повертає `None`.

## Бібліотека `re`

Давайте спробуємо переписати нашу програму використовуючи функцію `re.search()`:

```{python}
#| label: validate-re-search
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search("@", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: @
Валідна адреса електронної пошти
```

Цей варіант програми працює так само, як і наш перший варіант, але вже з використанням пакету `re`.

## Регулярні вирази {.smaller}

Нам треба уточнити потер пошуку: ліворуч від символа `@` може бути певний запис, праворуч від символа `@` має бути також якийсь запис, який закінчується на `.edu`. Для цього існує ряд спеціальних символів, які дозволяють визначити певні шаблони:

| **Регулярний вираз** | **Опис** | **Приклади** |
|:-----------------:|:------|----------|
| `.`             | Будь-який символ | `a.b` = "acb", "a1b", "a#b" |
| `*`             | 0 або більше повторень попереднього символу | `ab*c` = "ac", "abc", "abbc" |
| `+`             | 1 або більше повторень попереднього символу | `ab+c` = "abc", "abbc", але не "ac" |
| `?`             | 0 або 1 повторення попереднього символу | `colou?r` = "color" і "colour" |
| `{n}`           | Рівно `n` повторень попереднього символу | `a{3}b` = "aaab" |
| `{n, m}`        | Від `n` до `m` повторень попереднього символу | `a{2,4}b` = "aab", "aaab" і "aaaab" |
| `{n,}`          | Від `n` повторень попереднього символу | `a{2,}b` = "aab", "aaab", "aaaab" і так далі |
| `^`             | Початок рядка | `^start` =, якщо рядок починається з "start" |
| `$`             | Кінець рядка | `end$` =, якщо рядок закінчується на "end" |
| `[]`            | Набір символів | `[aeiou]` = будь-якому голосному символу |
| `[^]`           | Набір символів, які не повинні зустрічатися | `[^0-9]` = будь-якому символу, крім цифр |
| `A|B`           | Або | `cat|dog` = "cat" або "dog" |
| `(...)`         | Група символів | `(ab)+` = "ab", "abab", "ababab" і так далі |
| `?:...`         | Не захоплювати групу | `(?:ab)+` = "ab", "abab", "ababab" і так далі |

: {tbl-colwidths="[20,50,30]"}

## Регулярні вирази {.nostretch}

Давайте спробуємо переписати нашу програму використовуючи функцію `re.search()` і регулярний вираз:

```{python}
#| label: validate-re-search-edu-ua
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(".*@.*", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

Комп'ютер використовує свого роду машину, реалізовану в програмному забезпеченні, відомому як **скінченний автомат** (англ. *finite state machine*) або **недетермінований скінченний автомат**. 

Візуально це можна зобразити так:

![Вираз: `.*@.*`](img/regex-email-00.png)

## Регулярні вирази {.nostretch}

Ми можемо переписати нашу програму з використанням регулярного виразу `.+`, який означає "один або більше будь-яких символів":


```{python}
#| label: validate-re-search-edu-ua-2
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(".+@.+", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

В такому випадку візуалізація недетермінованого скінченного автомату буде наступна:

![Вираз: `.+@.+`](img/regex-email-01.png)

## Регулярні вирази {.nostretch .smaller}

Підемо далі і додамо перевірку, що домен закінчується на `.edu`:

```{python}
#| label: validate-re-search-edu-ua-3
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r".+@.+\.edu", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: potter?hogwarts.edu
Невалідна адреса електронної пошти
```

::: {.callout-warning}
Зверніть увагу, що ми використовуємо символ `\` для екранування крапки, оскільки в іншому випадку крапка буде сприйматися як будь-який символ.

Крім того, слід враховувати, що комбінація символів `\n` вважається спеціальним символом, який позначає перехід на новий рядок. Тому ми вказуємо Python читати рядок як **"сирий"** (англ. *raw*), використовуючи префікс `r` перед рядком.
:::

Візуалізація:

![Вираз: `.+@.+\.edu`](img/regex-email-02.png)

## Початок та кінець рядка {.smaller .nostretch}

Наша програма все ще має ряд недоліків. Наприклад, вона не враховує пробіли, які можуть зустрічатися у введеному тексті:

```{.bash filename="Terminal"}
python validate.py
Введіть email: Моя пошта potter@hogwarts.edu
Валідна адреса електронної пошти
```

Для таких випадків у світі регулярних виразів існують спеціальні символи початку `^` та кінця рядка `$`:

```{python}
#| label: validate-re-search-edu-ua-4
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^.+@.+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: Моя пошта potter@hogwarts.edu
Невалідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^.+@.+\.edu$`](img/regex-email-03.png)

## Пошук та вилучення {.smaller .nostretch}

Є ще один значний недолік нашої програми. Вона не враховує умову одного символу `@` у адресі електронної пошти:

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@@@hogwarts.edu
Валідна адреса електронної пошти
```

Для цього ми можемо використати символи `[]` для визначення набору символів, які можуть зустрічатися у тексті та `[^]` для символів, які не повинні зустрічатися у тексті. Оскільки ми не хочемо щоб символ `@` зустрічався більше одного разу, то ми можемо використати наступний регулярний вираз `[^@]`:

```{python}
#| label: validate-re-search-edu-ua-5
#| eval: false 

import re

email = input("Введіть email: ").strip()

if re.search(r"^[^@]+@[^@]+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@@@hogwarts.edu
Невалідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^[^@]+@[^@]+\.edu$`](img/regex-email-04.png)

## Слова та цифри {.smaller .nostretch}

У світі стандартів існує багато різних специфікацій для адрес електронної пошти. Наприклад, вони повинні починатися з літери. Нам не потрібно перераховувати всі можливі літери алфавіту у нижньому та верхньому регістрі. Замість цього ми можемо використати спеціальний символ `[a-zA-Z]`, який означає будь-яку літеру англійського алфавіту незалежно від регістру. Якщо ж я хочу також врахувати цифри та символ `_`, то я можу використати спеціальний символ `[a-zA-Z0-9_]`. Давайте спробуємо використати цей регулярний вираз:

```{python}
#| label: validate-re-search-edu-ua-6
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@@@hogwarts.edu
Невалідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\.edu$`](img/regex-email-05.png)

## Слова та цифри {.smaller .nostretch}

Такі патерни досить часто зустрічаються, тому у регулярних виразах є готові спеціальні символи, які дозволяють замінити їх. 

Наприклад, спеціальний метасимвол `\w` означає **будь-яку літеру англійського алфавіт**у незалежно від регістру, цифру або символ `_`. 

Також є спеціальний метасимвол `\d`, який означає **будь-яку цифру**.

```{python}
#| label: validate-re-search-edu-ua-7
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^\w+@\w+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

Візуалізація:

![Вираз: `^\w+@\w+\.edu$`](img/regex-email-06.png)

## Слова та цифри {.nostretch}

Повний перелік спеціальних метасимволів:

| **Метасимвол** | **Опис** |
|:------------|:------|
| `\w` | Будь-яка літера англійського алфавіту незалежно від регістру, цифра або символ `_` |
| `\d` | Будь-яка цифра |
| `\s` | Будь-який пробіл |
| `\W` | Будь-який символ, крім літер англійського алфавіту незалежно від регістру, цифр та символу `_` |
| `\D` | Будь-який символ, крім цифри |
| `\S` | Будь-який символ, крім пробілу |

: {tbl-colwidths="[25,75]"}

## Флаги {.smaller}

Давайте припустимо, що при введені адреси електронної пошти користувач випадково натиснув клавішу <kbd>Caps Lock</kbd> і ввів адресу з використанням великих літер. 

Якщо ми використаємо наш регулярний вираз, то програма не буде вважати таку адресу валідною:

```{.bash filename="Terminal"}
python validate.py
Введіть email: POTTER@HOGWARTS.EDU
Невалідна адреса електронної пошти
```

Вирішити таку задачу можна декількома шляхами.

Наприклад, ми можемо використати функцію `lower()` для перетворення всіх символів у нижній регістр. Це можна зробити на початку програми або використовуючи метод `lower()` для об'єкта `email`:

```{python}
#| label: validate-re-search-edu-ua-8
#| eval: false

import re

email = input("Введіть email: ").strip().lower()

if re.search(r"^\w+@\w+\.edu$", email): # або email.lower()
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

## Флаги {.smaller}

Але є інший спосіб. Ми можемо використати аргумент `flag` для функції `re.search()`, який може приймати наступні значення:

- `re.IGNORECASE` або `re.I` - ігнорувати регістр символів
- `re.MULTILINE` або `re.M` - використовувати багаторядковий режим
- `re.DOTALL` або `re.S` - використовувати режим, в якому крапка `.` відповідає будь-якому символу, включаючи символ нового рядка `\n`

Тож для нашої задачі код буде виглядати наступним чином:

```{python}
#| label: validate-re-search-edu-ua-9
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^\w+@\w+\.edu$", email, re.IGNORECASE):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: POTTER@HOGWARTS.EDU
Валідна адреса електронної пошти
```

## Опціональність {.smaller .nostretch}

Припустимо, що адреса користувача містить піддомен `gryff.hogwarts.edu`. В такому випадку нам слід врахувати варіативність піддоменів. Для цього ми можемо використати спеціальний символ `?`, який означає 0 або 1 повторення попереднього символу. Давайте спробуємо використати цей символ:

```{python}
#| label: validate-re-search-edu-ua-10
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^\w+@(\w+\.)?edu$", email, re.IGNORECASE):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: potter@gryff.hogwarts.edu
Валідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^\w+@(\w+\.)?edu$`](img/regex-email-07.png)

Запис `(\w+\.)?` означає, що група записів `\w+\.` може зустрічатися 0 або 1 раз. Таким чином, ми можемо врахувати варіативність піддоменів.

## Приклади з реального світу {.smaller}

Все що ми зробили до цього часу для відстеження адрес електронної пошти, все ще має ряд недоліків. Я наведу приклад регулярного виразу, який використовується в реальному світі для відстеження адрес електронної пошти:

```
^[a-zA-Z0-9_.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9-](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9-](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)
```

Візуально такий регулярний вираз виглядає так:

![Приклад валідації email](img/regex-email-08.png)

## Приклади з реального світу {.smaller}

В інтернеті є ряд стандартів, які визначають, якими мають бути адреси електронної пошти. Один з них - це [RFC 5322](https://tools.ietf.org/html/rfc5322). Згідно цього стандарту 99.99% адрес електронної пошти можна відстежити за допомогою наступного регулярного виразу:

```
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

Візуально такий запис виглядає наступним чином:

![Валідація email за RFC 5322](img/regex-email-09.png)

## Очищення тексту {.smaller}

Замість того, щоб просто перевіряти вхідні дані користувача і переконуватися, що вони виглядають так, як ми хочемо, давайте просто припустимо, що користувачі не збираються вводити дані саме так, як ми хочемо. Тому нам доведеться очистити їхні дані.

Створимо програму `format.py`, яка очищуватиме введене ім'я користувача:

```{.bash filename="Terminal"}
code format.py
```

Деякі користувачі можуть мати звичку вводити спочатку своє ім'я, а потім прізвище через кому: `Гаррі, Поттер` замість `Поттер, Гаррі`. Це нормально, тому що обидва варіанти однаково добре читаються людиною. Але для комп'ютера це різні рядки. Тому нам потрібно буде очистити введені дані користувача. Створимо змінну `name`, яка буде містити введені дані користувача:

```{python}
#| label: format-name
#| eval: false

name = input("Введіть ім'я: ").strip()
print(f'Привіт, {name}!')
```

Подивимось, як працює програма з різними введеними даними:

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Гаррі Поттер
Привіт, Гаррі Поттер!
```

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Поттер, Гаррі
Привіт, Поттер, Гаррі!
```

## Очищення тексту {.smaller}

Перший варіант нас може задовільнити, а от другий виглядає зовсім не так, як ми очікуємо. Давайте спробуємо виправити цю ситуацію через умовний оператор `if`:

```{python}
#| label: format-name-2
#| eval: false

name = input("Введіть ім'я: ").strip()

if ',' in name:
    last, first = name.split(', ')
    name = f'{first} {last}'

print(f'Привіт, {name}!')
```

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Поттер, Гаррі
Привіт, Гаррі Поттер!
```

Ми виправили ситуацію, але що якщо користувач введе ім'я без використання пробілів? Наприклад, `Поттер,Гаррі`?

Це призведе до помилки, оскільки ми використовуємо метод `split()` для розділення рядка на дві частини.

Для цього нам знадобиться функція `re.search()`, яка повертає об'єкт `Match`. Якщо відповідність знайдена, то ми можемо використати метод `groups()` для отримання відповідного значення, які були записані у дужки.

## Очищення тексту {.smaller}

Давайте спробуємо використати регулярний вираз `^(.+), (.+)$`, який означає *"початок рядка, один або більше будь-яких символів, кома, пробіл, один або більше будь-яких символів, кінець рядка"*:

```{python}
#| label: format-name-3
#| eval: false

import re

name = input("Введіть ім'я: ").strip()

matches = re.search(r'^(.+), (.+)$', name)

if matches:
    last, first = matches.groups()
    name = f'{first} {last}'

print(f'Привіт, {name}!')
```

Якщо ми введемо ім'я користувача без коми, то з умовним оператором `if` нічого не буде відбуватися, оскільки `matches` буде `None` і програма одразу перейде до виведення привітання:

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Гаррі Поттер
Привіт, Гаррі Поттер!
```

У випадку, коли користувач введе ім'я з комою, то відбудеться відповідність регулярному виразу і ми зможемо використати метод `groups()` для отримання відповідних значень:

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Поттер, Гаррі
Привіт, Гаррі Поттер!
```

## Очищення тексту {.smaller}

Якщо ж потрібно повернути конкретні групи замість всіх, то можна використати метод `group()`, який приймає номер групи:

```{python}
#| label: format-name-4
#| eval: false

import re

name = input("Введіть ім'я: ").strip()

matches = re.search(r'^(.+), (.+)$', name)

if matches:
    name = f'{matches.group(2)} {matches.group(1)}'

print(f'Привіт, {name}!')
```

Ця програма має значний недолік - ми очікуємо, що ім'я та прізвище користувача будуть розділені одним пробілом. Якщо користувач введе ім'я без пробілу або навпаки використає декілька, то програма виведе не те, що ми очікуємо:

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Поттер,Гаррі
Привіт, Поттер,Гаррі!
```

## Очищення тексту {.smaller}

Перший варіант, як врахувати таку ситуацію - це додати `*` до регулярного виразу:`^(.+), *(.+)?$`.

Це буде означати *"початок рядка, один або більше будь-яких символів, кома, нуль або більше пробілів, один або більше будь-яких символів, кінець рядка"*:

```{python}
#| label: format-name-5
#| eval: false

import re

name = input("Введіть ім'я: ").strip()

matches = re.search(r'^(.+), *(.+)?$', name)

if matches:
    name = f'{matches.group(2)} {matches.group(1)}'

print(f'Привіт, {name}!')
```

```{.bash filename="Terminal"}
python format.py
Введіть ім'я: Поттер,Гаррі
Привіт, Гаррі Поттер!

python format.py
Введіть ім'я: Поттер,      Гаррі
Привіт, Гаррі Поттер!
```

::: {.callout-warning}
Залежно від того, наскільки безладними є дані, ваші регулярні вирази можуть ставати все складнішими і складнішими. Кількість умов напряму впливає на їх складність.
:::

## Моржевий оператор

Ми можемо скоротити наш код, використовуючи "моржевий оператор" `:=` (англ. *walrus operator*), який дозволяє присвоювати значення змінній та одночасно використовувати її у виразі:

```{python}
#| label: format-name-6
#| eval: false

import re

name = input("Введіть ім'я: ").strip()

if matches := re.search(r'^(.+), *(.+)?$', name):
    name = f'{matches.group(2)} {matches.group(1)}'

print(f'Привіт, {name}!')
```

## Отримання даних з рядка

Розглянемо варіант програми, де нам потрібно отримати дані з рядка, щоб відповісти на якесь питання. Наприклад, давайте створимо програму `twitter.py`, яка буде запитувати у користувачів URL-адресу їхнього профілю в Twitter і витягти з неї ім'я користувача:

```{.bash filename="Terminal"}
code twitter.py
```

Розглянемо рядок `https://twitter.com/harrypotter`. Перше на що звертаємо увагу - це те, адреса сервісу завжди починається з `https://twitter.com/`. Тому ми можемо замінити цю частину рядка на порожній рядок. Для цього ми можемо використати метод `replace()`:

```{python}
#| label: twitter-username

url = 'https://twitter.com/harrypotter'

username = url.replace('https://twitter.com/', '')
print(f"Ім'я користувача: {username}")
```

## Отримання даних з рядка {.smaller}

Але така проста програма не враховує низку ситуацій:

- адреса може починатися без ``https://``
- адреса може починатися з ``http://``
- адреса може містити `www.`
- тощо

Використаємо бібліотеку функцію:

`re.sub(pattern, repl, string, count=0, flags=0)`,

яка замінює всі входження патерну `pattern` на `repl` у рядку `string`. 

Використаємо регулярний вираз `^(https?://)?(www\.)?twitter\.com/`, який читається як: *"початок рядка, група символів `https://` або `http://` 0 або 1 раз, група символів `www.` 0 або 1 раз, `twitter.com/`"*:

```{python}
#| label: twitter-username-2

import re

url = 'https://twitter.com/harrypotter'

username = re.sub(r'^(https?://)?(www\.)?twitter\.com/', '', url)

print(f"Ім'я користувача: {username}")
```

## Отримання даних з рядка

Проте, якщо користувач введе замість URL-адреси Twitter адресу іншого сервісу, регулярний вираз працювати не буде:

```{python}
#| label: twitter-username-3

import re

url = 'https://facebook.com/harrypotter'

username = re.sub(r'^(https?://)?(www\.)?twitter\.com/', '', url)

print(f"Ім'я користувача: {username}")
```

## Отримання даних з рядка

В такому випадку ми можемо повернутися до `re.search()` та використати групи для отримання імені користувача, але для виключення певної групи з переліку можна використати `?:`:

```{python}
#| label: twitter-username-4

import re

url = 'https://facebook.com/harrypotter'

if matches := re.search(r'^https?://(?:www\.)?twitter\.com/(.+)$', url, re.IGNORECASE):
    username = matches.group(1)
    print(f"Ім'я користувача: {username}")
else:
    print('Невідомий сервіс')
```

Тепер програма буде працювати з будь-якими URL-адресами:

```{python}
#| label: twitter-username-5

import re

url = 'https://www.twitter.com/harrypotter'

if matches := re.search(r'^https?://(?:www\.)?twitter\.com/(.+)$', url, re.IGNORECASE):
    username = matches.group(1)
    print(f"Ім'я користувача: {username}")
else:
    print('Невідомий сервіс')
```

## Отримання даних з рядка {.smaller}

Якщо ж ознайомитися з документацією Twitter, то можна знайти, що ім'я користувача може містити тільки літери, цифри, символ `_`, тобто не просто `.+`, що може бути чим завгодно. Тому ми можемо використати регулярний вираз `[a-z0-9_]+` для більш точного пошуку імені користувача, який читається як: *"будь-яка літера англійського алфавіту, цифра або символ `_` 1 або більше разів"*:

```{python}
#| label: twitter-username-6

import re

url = 'https://www.twitter.com/harrypotter'

if matches := re.search(r'^https?://(?:www\.)?twitter\.com/([a-z0-9_]+)$', url, re.IGNORECASE):
    username = matches.group(1)
    print(f"Ім'я користувача: {username}")
else:
    print('Невідомий сервіс')
```

В пакеті `re` є ряд цікавих функцій:

- `re.split(pattern, string, maxsplit=0, flags=0)` - розбиває рядок на частини за допомогою регулярного виразу
- `re.findall(pattern, string, flags=0)` - повертає список всіх знайдених входжень регулярного виразу

::: {.callout-tip}
Для побудови, тестування та налагодження регулярних виразів можна використовувати [regex101.com](https://regex101.com/).
:::

# Дякую за увагу! {.unnumbered .unlisted background-iframe="colored-particles/index.html"}

<br>
<br>

{{< iconify solar book-bold >}} [Матеріали курсу](https://aranaur.rbind.io/lectures/applied_analytics/)

{{< iconify mdi envelope >}} ihor.miroshnychenko\@kneu.ua

{{< iconify ic baseline-telegram >}} [Data Mirosh](https://t.me/araprof)

{{< iconify mdi linkedin >}} [\@ihormiroshnychenko](https://www.linkedin.com/in/ihormiroshnychenko/)

{{< iconify mdi github >}} [\@aranaur](https://github.com/Aranaur)

{{< iconify ion home >}} [aranaur.rbind.io](https://aranaur.rbind.io)