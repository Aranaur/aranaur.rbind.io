---
title: Завдання №6
subtitle: "Прикладна аналітика"
format:
    html: default
    pdf:
        # include-in-header: preamble.tex
        mainfont: Roboto
        monofont: Roboto
        fontfamily: roboto
toc: true
---

# Регулярні вирази

## 1. 4исла

::: {.column-margin}
![](img/numb3rs.png)
:::

{{< video https://www.youtube.com/watch?v=CTVryXOF1rw >}}

У 23-й серії 5-го сезону [4исла](https://uk.wikipedia.org/wiki/4%D0%B8%D1%81%D0%BB%D0%B0) на екрані з'являється IP-адреса `275.3.6.28`, яка насправді не є дійсною адресою [IPv4](https://en.wikipedia.org/wiki/Internet_Protocol_version_4) (або [IPv6](https://en.wikipedia.org/wiki/IPv6)).

IPv4-адреса - це числовий ідентифікатор, який пристрій (або, на телебаченні, хакер) використовує для зв'язку в Інтернеті, подібно до поштової адреси в реальному світі, зазвичай відформатований у [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) як `#.#.#.#`. Але кожна `#` має бути числом від `0` до `255` включно. Вже видно, що `275` не знаходиться в цьому діапазоні! Давайте допоможемо героям серіалу перевірити адресу у цій сцені!

У файлі з назвою `numb3rs.py` реалізуйте функцію з назвою `validate`, яка очікує IPv4-адресу на вході у вигляді `str`, а потім повертає `True` або `False`, відповідно, якщо цей ввід є дійсною IPv4-адресою чи ні.

Структуруйте `numb3rs.py` наступним чином, при цьому ви можете змінювати `main` та/або реалізовувати інші функції на свій розсуд, але ви не можете імпортувати інші бібліотеки. Ви можете, але не зобов'язані використовувати `re` та/або `sys`.

```{.python}
import re
import sys

def main():
    print(validate(input("IPv4 Address: ")))

def validate(ip):
    ...

...

if __name__ == "__main__":
    main()
```

### Додаткове (необов'язкове) завдання.

До або після того, як ви реалізуєте `validate` в `numb3rs.py`, додатково реалізуйте у файлі з назвою `test_numb3rs.py` дві або більше функцій, які ретельно тестують вашу реалізацію `validate`, кожна з яких повинна починатися з `test_`, щоб ви могли виконати ваші тести з ними:

```{.python}
pytest test_numb3rs.py
```

::: {.callout-note collapse="true"}
## Підказка

- Модуль `re` постачається з багатьма [функціями](https://docs.python.org/3/library/re.html) включаючи з `search`.
- Регулярні вирази підтримують багато [спеціальних символів](https://docs.python.org/3/library/re.html#regular-expression-syntax).
- Оскільки зворотні слеші у регулярних виразах можуть бути сприйняті як екрановані послідовності (наприклад, `\n`), для шаблонів регулярних виразів краще використовувати [сирі позначення рядків у Python](https://docs.python.org/3/library/re.html#module-re), інакше `pytest` видасть попередження `DeprecationWarning: invalid escape sequence`. Так само, як форматовані рядки мають префікс `f`, так і сирі рядки мають префікс `r`. Наприклад, замість `"knu\.edu"`, використовуйте `r"knu\.edu"`.
- Якщо `re.search` передано шаблон з "групами" (тобто дужками), повертає [`match object`](https://docs.python.org/3/library/re.html#match-objects), де збіги мають 1-індекс, до якого ви можете отримати доступ індивідуально за допомогою [`group`](https://docs.python.org/3/library/re.html#re.Match.group) або цілу групу за допомогою [`groups`](https://docs.python.org/3/library/re.html#re.Match.groups).
:::

## 2. Дивимось Youtube

::: {.column-margin}
![](img/gendalf.jpg)
:::

Більшість відео з YouTube можна вбудовувати в інші веб-сайти, так само, як це було у першому завданні. Наприклад, якщо ви перейдете за [посиланням](https://www.youtube.com/watch?v=w0drLyhnByk), натиснете "Поділитися", а потім "Вбудувати", ви побачите [HTML](https://en.wikipedia.org/wiki/HTML)-код (мова, якою написані веб-сторінки), як показано нижче, який ви можете скопіювати у вихідний код вашого веб-сайту, де [`iframe`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) - це "елемент" HTML, а `src` - один з декількох "атрибутів" HTML, значенням якого є `https://www.youtube.com/embed/w0drLyhnByk`.

```{.html}
<iframe width="560" height="315" src="https://www.youtube.com/embed/w0drLyhnByk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
```

Оскільки деякі атрибути HTML є необов'язковими, ви можете мінімально використати лише наступні:

```{.html}
<iframe src="https://www.youtube.com/embed/w0drLyhnByk"></iframe>
```

Припустимо, що ви хочете витягти URL-адреси відео на YouTube, вбудовані у сторінки (наприклад, `https://www.youtube.com/embed/w0drLyhnByk`), перетворивши їх назад у коротші URL-адреси `youtu.be` (наприклад, `https://youtu.be/w0drLyhnByk`), за якими їх можна буде переглянути на самому YouTube.

У файлі `watch.py` реалізуйте функцію `parse`, яка очікує на вхідний `str` HTML, витягує будь-яку URL-адресу YouTube, що відповідає значенню атрибуту `src` елемента `iframe`, і повертає його коротший еквівалент на `youtu.be` у вигляді рядка. Очікується, що будь-яка така URL-адреса буде в одному з наведених нижче форматів. Вважайте, що значення `src` буде взято у подвійні лапки. І припустимо, що вхідні дані містять не більше однієї такої URL-адреси. Якщо вхідні дані не містять жодної такої URL-адреси, виведіть `None`.

- `http://youtube.com/embed/w0drLyhnByk`
- `https://youtube.com/embed/w0drLyhnByk`
- `https://www.youtube.com/embed/w0drLyhnByk`

Структуруйте `watch.py` наступним чином, при цьому ви можете змінювати `main` та/або реалізовувати інші функції на свій розсуд, але ви не можете імпортувати інші бібліотеки. Ви можете, але не зобов'язані використовувати `re` та/або `sys`:

```{.python}
import re
import sys

def main():
    print(parse(input("HTML: ")))

def parse(s):
    ...

...

if __name__ == "__main__":
    main()
```

::: {.callout-note collapse="true"}
## Підказка

- Зауважте, що `*` і `+` є "жадібними", оскільки ["вони зіставляють якомога більше тексту"](https://docs.python.org/3/library/re.html#regular-expression-syntax). Додавання `?` одразу після `*?` або `+?` "робить пошук не жадібним або мінімальним; буде знайдено якомога менше символів".
:::

## 3. Робота з 9 до 5

::: {.column-margin}
![](img/time.png)
:::

У той час як [більшість країн](https://en.wikipedia.org/wiki/Date_and_time_representation_by_country#Time) використовують [24-годинний формат часу](https://uk.wikipedia.org/wiki/24-%D0%B3%D0%BE%D0%B4%D0%B8%D0%BD%D0%BD%D0%B8%D0%B9_%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82_%D1%87%D0%B0%D1%81%D1%83) , Сполучені Штати, як правило, використовують [12-годинний формат часу](https://uk.wikipedia.org/wiki/12-%D0%B3%D0%BE%D0%B4%D0%B8%D0%BD%D0%BD%D0%B8%D0%B9_%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82_%D1%87%D0%B0%D1%81%D1%83).

Відповідно, замість "з 09:00 до 17:00" багато американців скажуть, що працюють "9:00 AM до 5:00 PM" (або "9 AM до 5 PM"), де "AM" - це скорочення від "ante meridiem", а "PM" - це скорочення від "post meridiem", де "meridiem" означає полудень (тобто, полудень).

::: {.callout-note collapse="true"}
## Таблиця перетворення

Так само, як "12:00 AM" у 12-годинному форматі буде "00:00" у 24-годинному форматі, так і "12:01 AM" до "12:59 AM" буде "00:01" до "00:59" відповідно.

| **12-годин ** | **24-годин ** |
|--------------|--------------|
| 12:00 AM     | 00:00        |
| 1:00 AM      | 01:00        |
| 2:00 AM      | 02:00        |
| 3:00 AM      | 03:00        |
| 4:00 AM      | 04:00        |
| 5:00 AM      | 05:00        |
| 6:00 AM      | 06:00        |
| 7:00 AM      | 07:00        |
| 8:00 AM      | 08:00        |
| 9:00 AM      | 09:00        |
| 10:00 AM     | 10:00        |
| 11:00 AM     | 11:00        |
| 12:00 PM     | 12:00        |
| 1:00 PM      | 13:00        |
| 2:00 PM      | 14:00        |
| 3:00 PM      | 15:00        |
| 4:00 PM      | 16:00        |
| 5:00 PM      | 17:00        |
| 6:00 PM      | 18:00        |
| 7:00 PM      | 19:00        |
| 8:00 PM      | 20:00        |
| 9:00 PM      | 21:00        |
| 10:00 PM     | 22:00        |
| 11:00 PM     | 23:00        |
| 12:00 AM     | 00:00        |

: {.striped .hover}
:::

У файлі `working.py` реалізуйте функцію `convert`, яка отримує `str` у будь-якому з 12-годинних форматів, наведених нижче, і повертає відповідний `str` у 24-годинному форматі (тобто, з `9:00 to 17:00`). Очікується, що `AM` і `PM` будуть написані великими літерами (без крапок), а перед кожним з них буде пробіл.

- `9:00 AM to 5:00 PM`
- `9 AM to 5 PM`

Викличіть `ValueError`, якщо вхідні дані для `convert` не містять жодного з цих форматів або якщо час є недійсним (наприклад, `12:60 AM`, `13:00 PM`, тощо). 

Врахуйте, що не обов'язково робочий день починається AM і закінчується PM; хтось може працювати допізна і навіть довше (наприклад, з `5:00 PM to 9:00 AM`).

Структуруйте `working.py` наступним чином, ви можете `main` та/або реалізовувати інші функції на свій розсуд, але ви не можете імпортувати будь-які інші бібліотеки. Ви можете, але не зобов'язані використовувати `re` та/або `sys`: 

```{.python}
import re
import sys


def main():
    print(convert(input("Hours: ")))


def convert(s):
    ...


...


if __name__ == "__main__":
    main()
```

::: {.callout-note collapse="true"}
## Підказка

- Зверніть увагу, що ви можете відформатувати `int` з початковими нулями за допомогою коду на зразок

```{python}
n = 1
print(f"{n:02}")
```

де, якщо `n` є однозначним числом, до нього [буде додано](https://docs.python.org/3/library/string.html#format-string-syntax) один `0`.
:::

## 4. Звук-паразит

::: {.column-margin}
![](img/um.jpg)
:::

В англійській мові не рідкість сказати "um" (на кшталт українського "еее"), коли намагаєшся придумати слово. Однак, чим більше ви це робите, тим помітніше це стає!

У файлі `um.py` реалізуйте функцію `count`, яка приймає на вхід рядок тексту як `str` і повертає як `int`, яка рахує кількість разів "um" у тексті, незалежно від регістру, як окреме слово, а не як частина якогось іншого слова.

Наприклад, для тексту типу `hello, um, world`, функція має повернути `1`. Однак, для тексту типу `yummy`, функція повинна повернути `0`.

Структуруйте `um.py` наступним чином, ви можете змінювати `main` та/або реалізовувати інші функції на власний розсуд, але ви не можете імпортувати інші бібліотеки. Ви можете, але не зобов'язані використовувати `re` та/або `sys`:

```{.python}
import re
import sys

def main():
    print(count(input("Text: ")))

def count(s):
    ...

...

if __name__ == "__main__":
    main()
```

::: {.callout-note collapse="true"}
## Підказка

- Ви можете скористатися сайтами [regex101.com](https://regex101.com/) або [regexr.com](https://regexr.com/) для тестування регулярних виразів (і візуалізації збігів).
- Деякі слова, що містять "um", можна знайти на сторінці <https://www.thefreedictionary.com/words-containing-um>.
:::

## 5. Валідатор

::: {.column-margin}
![](img/email-validation.png)
:::

При створенні [Google форм](https://www.google.com/forms/about/), яка пропонує користувачам ввести коротку відповідь (або абзац), можна увімкнути [перевірку відповіді](https://support.google.com/docs/answer/3378864) і вимагати, щоб дані, введені користувачем, відповідали [регулярному виразу](https://support.google.com/a/answer/1371415).

Наприклад, ви можете вимагати, щоб користувач ввів адресу електронної пошти з регулярним виразом на зразок [цього](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address):

```{.markdown}
^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$
```

Або ж ви можете скористатися вбудованою підтримкою Google для перевірки адреси електронної пошти, як показано на скріншоті нижче, подібно до того, як ви можете використовувати бібліотеку у вашому власному коді:

![](img/form.png)

У файлі `response.py`, використовуючи [validator-collection](https://pypi.org/project/validator-collection/) або [validators](https://github.com/python-validators/validators) з PyPI, реалізуйте програму, яка запрошує користувача ввести адресу електронної пошти, а потім друкує `Valid` або `Invalid`, відповідно, якщо введена адреса є синтетично дійсною. 

Ви не можете використовувати `re` і перевіряти, чи існує доменне ім'я адреси електронної пошти насправді.

::: {.callout-note collapse="true"}
## Підказка

- Ви можете встановити validator-collection за допомогою:

```{.bash filename='Terminal'}
pip install validator-collection
```

- Ви можете встановити validators за допомогою:

```{.bash filename='Terminal'}
pip install validators
```
:::